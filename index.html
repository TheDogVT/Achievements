<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Achievements Viewer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        /* ── LOADING SCREEN ── */
        #loadingScreen {
            position: fixed; inset: 0;
            background: #1B1A1A;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
            gap: 24px;
            transition: opacity 0.4s ease;
        }
        #loadingScreen.fade-out { opacity: 0; pointer-events: none; }
        .loading-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #fff 0%, #C6E8E8 60%, #8ed8d8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 0.06em;
        }
        .loading-bar-wrap {
            width: 280px;
            height: 4px;
            background: rgba(198, 232, 232, 0.15);
            border-radius: 99px;
            overflow: hidden;
        }
        .loading-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #C6E8E8, #fff);
            border-radius: 99px;
            width: 0%;
            transition: width 0.15s ease;
        }
        #loadingStatus {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: rgba(198, 232, 232, 0.6);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        #appContent { display: none; }
    </style>
    <style>
        :root {
            --bg:       #1B1A1A;
            --surface:  #252424;
            --card:     #2d2c2c;
            --border:   rgba(198, 232, 232, 0.15);
            --cyan:     #C6E8E8;
            --cyan-dim: #8ed8d8;
            --cyan-bright: #e0f5f5;
            --text:     #ffffff;
            --muted:    rgba(198, 232, 232, 0.5);
            --radius:   10px;
        }

        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
        }

        /* ── CONSTELLATION BACKGROUND ── */
        #constellation {
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
        }
        body.star-game-active #constellation {
            pointer-events: auto;
            cursor: crosshair;
            z-index: 10;
        }
        body.save-stars-active #constellation {
            pointer-events: auto;
            cursor: crosshair;
            z-index: 10;
        }

        .page-wrap {
            position: relative;
            z-index: 1;
            width: 100%;
            max-width: 900px;
            padding: 32px 20px 60px;
            display: flex;
            flex-direction: column;
            gap: 28px;
        }

        /* ── HEADER ── */
        header {
            text-align: center;
        }
        header .eyebrow {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.25em;
            color: var(--cyan);
            text-transform: uppercase;
            margin-bottom: 6px;
            text-shadow: 0 0 8px rgba(198, 232, 232, 0.4);
        }
        header h1 {
            font-size: clamp(2rem, 6vw, 3.4rem);
            font-weight: 700;
            letter-spacing: 0.05em;
            line-height: 1;
            background: linear-gradient(135deg, #fff 0%, var(--cyan) 60%, var(--cyan-dim) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 12px rgba(198, 232, 232, 0.3));
        }
        header .subtitle {
            margin-top: 6px;
            color: var(--muted);
            font-size: 1rem;
            font-weight: 500;
        }

        /* ── LEADERBOARD ── */
        .leaderboard {
            background: rgba(37, 36, 36, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 20px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        .leaderboard-timer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(198, 232, 232, 0.15);
            border-radius: 14px 14px 0 0;
            overflow: hidden;
            display: none;
        }
        .leaderboard-timer-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--cyan), var(--cyan-bright));
            width: 100%;
            transition: width 5s linear;
            box-shadow: 0 0 8px rgba(198, 232, 232, 0.6);
        }
        .leaderboard.auto-collapsing .leaderboard-timer-fill {
            width: 0%;
        }
        .leaderboard-timer-label {
            position: absolute;
            top: -18px;
            right: 20px;
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: rgba(198, 232, 232, 0.4);
            letter-spacing: 0.05em;
            text-transform: uppercase;
            display: none;
            cursor: pointer;
            transition: color 0.2s;
        }
        .leaderboard-timer-label:hover {
            color: rgba(198, 232, 232, 0.7);
        }
        .leaderboard.auto-collapsing .leaderboard-timer-label {
            display: block;
        }
        .leaderboard-keep-open {
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            color: var(--muted);
            cursor: pointer;
            margin-left: 8px;
            transition: color 0.2s;
        }
        .leaderboard-keep-open:hover {
            color: var(--cyan);
        }
        .leaderboard-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            padding-bottom: 16px;
            transition: all 0.2s;
        }
        .leaderboard-header:hover {
            color: var(--cyan-bright);
        }
        .leaderboard.collapsed .leaderboard-header {
            padding-bottom: 0;
        }
        .leaderboard-title {
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.2em;
            color: var(--cyan);
            text-transform: uppercase;
            text-shadow: 0 0 8px rgba(198, 232, 232, 0.4);
        }
        .leaderboard-toggle {
            font-size: 0.8rem;
            transition: transform 0.3s;
        }
        .leaderboard.collapsed .leaderboard-toggle {
            transform: rotate(180deg);
        }
        .leaderboard-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }
        .leaderboard.collapsed .leaderboard-content {
            max-height: 0;
            opacity: 0;
        }
        .leaderboard-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        .leaderboard-column {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .leaderboard-category {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--cyan-bright);
            text-align: center;
            margin-bottom: 4px;
            letter-spacing: 0.05em;
        }
        .leaderboard-item {
            background: rgba(45, 44, 44, 0.6);
            border: 1px solid rgba(198, 232, 232, 0.15);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: all 0.2s;
        }
        .leaderboard-item:hover {
            background: rgba(198, 232, 232, 0.08);
            border-color: rgba(198, 232, 232, 0.3);
            transform: translateY(-1px);
        }
        .leaderboard-user {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .leaderboard-user:hover {
            opacity: 0.8;
        }
        .leaderboard-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--cyan), var(--cyan-dim));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            color: #1B1A1A;
            flex-shrink: 0;
            box-shadow: 0 0 8px rgba(198, 232, 232, 0.3);
        }
        .leaderboard-username {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        .leaderboard-ach-name {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--cyan);
            line-height: 1.2;
        }
        .leaderboard-ach-desc {
            font-size: 0.65rem;
            color: var(--muted);
            line-height: 1.3;
        }
        .leaderboard-rarity {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: #ffd700;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.4);
            margin-top: 2px;
        }
        @media (max-width: 768px) {
            .leaderboard-grid {
                grid-template-columns: 1fr;
            }
        }

        /* ── SEARCH BAR ── */
        .search-card {
            background: rgba(37, 36, 36, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
        }
        .search-row {
            display: flex;
            gap: 10px;
        }
        .input-wrap {
            position: relative;
            flex: 1;
        }
        .input-wrap .icon {
            position: absolute;
            left: 14px; top: 50%;
            transform: translateY(-50%);
            color: var(--muted);
            pointer-events: none;
            font-size: 1.1rem;
        }
        #userIdInput {
            width: 100%;
            padding: 12px 14px 12px 40px;
            background: rgba(45, 44, 44, 0.8);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.05rem;
            font-weight: 500;
            outline: none;
            transition: all 0.2s;
        }
        #userIdInput::placeholder { color: var(--muted); }
        #userIdInput:focus {
            border-color: var(--cyan);
            box-shadow: 0 0 0 2px rgba(198, 232, 232, 0.1);
        }

        /* ── AUTOCOMPLETE ── */
        #autocomplete {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: rgba(37, 36, 36, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            max-height: 240px;
            overflow-y: auto;
            z-index: 10;
            display: none;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
        }
        #autocomplete.visible { display: block; }
        .autocomplete-item {
            padding: 10px 14px;
            cursor: pointer;
            transition: background 0.12s;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text);
            border-bottom: 1px solid rgba(198, 232, 232, 0.08);
        }
        .autocomplete-item:last-child { border-bottom: none; }
        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: rgba(198, 232, 232, 0.1);
            color: var(--cyan-bright);
        }
        .autocomplete-item .username {
            color: var(--text);
        }
        .autocomplete-item:hover .username,
        .autocomplete-item.selected .username {
            color: var(--cyan-bright);
        }
        .autocomplete-item .id {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--muted);
            margin-left: 6px;
        }
        .autocomplete-empty {
            padding: 14px;
            text-align: center;
            color: var(--muted);
            font-size: 0.85rem;
            font-style: italic;
        }

        .btn {
            padding: 12px 22px;
            border: none;
            border-radius: var(--radius);
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.18s ease;
            white-space: nowrap;
        }
        .btn-primary {
            background: var(--cyan);
            color: #1B1A1A;
            box-shadow: 0 0 12px rgba(198, 232, 232, 0.3);
        }
        .btn-primary:hover {
            background: var(--cyan-bright);
            transform: translateY(-1px);
            box-shadow: 0 0 20px rgba(198, 232, 232, 0.5);
        }
        .btn-primary:active { transform: translateY(0); }
        .btn-ghost {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
        }
        .btn-ghost:hover {
            border-color: var(--cyan);
            color: var(--cyan);
            box-shadow: 0 0 12px rgba(198, 232, 232, 0.2);
        }

        /* ── USER PROFILE BANNER ── */
        #profileBanner {
            display: none;
            align-items: center;
            gap: 14px;
            padding: 14px 16px;
            background: rgba(45, 44, 44, 0.8);
            border: 1px solid var(--border);
            border-radius: var(--radius);
        }
        #profileBanner.visible { display: flex; }
        .avatar {
            width: 42px; height: 42px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--cyan), var(--cyan-dim));
            display: flex; align-items: center; justify-content: center;
            font-weight: 700; font-size: 1.2rem; color: #1B1A1A;
            flex-shrink: 0;
            box-shadow: 0 0 12px rgba(198, 232, 232, 0.4);
        }
        .profile-info { flex: 1; }
        .profile-name {
            font-size: 1.1rem; font-weight: 700;
            color: var(--cyan-bright);
        }
        .profile-stats {
            font-family: 'Space Mono', monospace;
            font-size: 0.72rem;
            color: var(--muted);
            margin-top: 2px;
        }
        .progress-bar-wrap {
            height: 4px;
            background: rgba(198, 232, 232, 0.15);
            border-radius: 99px;
            overflow: hidden;
            margin-top: 6px;
            width: 100%;
            max-width: 200px;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--cyan), var(--cyan-bright));
            border-radius: 99px;
            transition: width 0.5s cubic-bezier(.4,0,.2,1);
            box-shadow: 0 0 8px rgba(198, 232, 232, 0.6);
        }
        .btn-clear {
            background: transparent;
            border: none;
            color: var(--muted);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 4px 8px;
            border-radius: 6px;
            transition: color 0.15s;
        }
        .btn-clear:hover { color: var(--text); }
        
        .btn-claim {
            padding: 6px 14px;
            background: rgba(198, 232, 232, 0.15);
            border: 1px solid var(--cyan);
            border-radius: 6px;
            color: var(--cyan);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            box-shadow: 0 0 8px rgba(198, 232, 232, 0.2);
        }
        .btn-claim:hover {
            background: rgba(198, 232, 232, 0.25);
            box-shadow: 0 0 16px rgba(198, 232, 232, 0.4);
            transform: translateY(-1px);
        }
        .btn-claim.claimed {
            background: rgba(80, 80, 90, 0.3);
            border-color: rgba(150, 150, 160, 0.4);
            color: rgba(180, 180, 190, 0.8);
            cursor: default;
            box-shadow: none;
        }
        .btn-claim.claimed:hover {
            transform: none;
        }

        /* ── TABS ── */
        .tabs-wrap {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .tabs-header {
            display: flex;
            gap: 4px;
            overflow-x: auto;
            scrollbar-width: none;
            padding-bottom: 2px;
            flex-wrap: wrap;
        }
        .tabs-header::-webkit-scrollbar { display: none; }
        .tab-btn {
            flex-shrink: 0;
            padding: 7px 16px;
            border: 1px solid var(--border);
            border-radius: 99px;
            background: transparent;
            color: var(--muted);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 0.04em;
            cursor: pointer;
            transition: all 0.18s;
            display: flex; align-items: center; gap: 6px;
        }
        .tab-btn .badge {
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            background: rgba(198, 232, 232, 0.1);
            border-radius: 99px;
            padding: 1px 6px;
            color: var(--muted);
            transition: all 0.18s;
        }
        .tab-btn:hover {
            border-color: var(--cyan-dim);
            color: var(--text);
        }
        .tab-btn.active {
            background: var(--cyan);
            border-color: var(--cyan);
            color: #1B1A1A;
            box-shadow: 0 0 12px rgba(198, 232, 232, 0.4);
        }
        .tab-btn.active .badge {
            background: rgba(0,0,0,0.2);
            color: #1B1A1A;
        }

        /* ── FILTER ROW (separate from sort) ── */
        .filter-row {
            display: none;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .filter-row.visible { display: flex; }
        
        /* ── SORT ROW (always visible) ── */
        .sort-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.72rem;
            color: var(--muted);
            letter-spacing: 0.08em;
        }
        .filter-chip {
            padding: 4px 12px;
            border: 1px solid var(--border);
            border-radius: 99px;
            background: transparent;
            color: var(--muted);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        .filter-chip:hover {
            border-color: var(--cyan-dim);
            color: var(--text);
        }
        .filter-chip.active {
            border-color: var(--cyan);
            color: var(--cyan-bright);
            background: rgba(198, 232, 232, 0.15);
            box-shadow: 0 0 8px rgba(198, 232, 232, 0.2);
        }

        .sort-select {
            padding: 4px 10px;
            background: rgba(45, 44, 44, 0.8);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            outline: none;
            transition: border-color 0.15s;
        }
        .sort-select:hover { border-color: var(--cyan-dim); }
        .sort-select option { background: var(--card); color: var(--text); }

        /* ── ACHIEVEMENT GRID ── */
        #achievementsContainer {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 14px;
            grid-auto-rows: minmax(auto, auto);
            align-items: start;
        }

        /* ── ACHIEVEMENT CARD ── */
        .achievement {
            background: rgba(45, 44, 44, 0.7);
            backdrop-filter: blur(8px);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px;
            position: relative;
            overflow: hidden;
            transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            cursor: default;
            animation: cardIn 0.25s ease both;
            display: flex;
            flex-direction: column;
        }
        @keyframes cardIn {
            from { opacity: 0; transform: translateY(8px); }
            to   { opacity: 1; transform: translateY(0); }
        }
        .achievement:hover {
            transform: translateY(-3px);
            border-color: rgba(198, 232, 232, 0.4);
            box-shadow: 0 8px 24px rgba(0,0,0,0.4), 0 0 20px rgba(198, 232, 232, 0.1);
        }
        /* sheen sweep */
        .achievement::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(110deg, transparent 30%, rgba(198, 232, 232, 0.08) 50%, transparent 70%);
            transform: translateX(-100%);
            transition: transform 0.5s ease;
        }
        .achievement:hover::before { transform: translateX(100%); }

        /* status stripe */
        .achievement::after {
            content: '';
            position: absolute;
            left: 0; top: 0; bottom: 0;
            width: 3px;
            background: rgba(198, 232, 232, 0.2);
            border-radius: 99px 0 0 99px;
        }
        .achievement.unlocked::after { background: var(--cyan); box-shadow: 0 0 8px rgba(198, 232, 232, 0.6); }
        .achievement.founded::after  { background: var(--cyan-bright); box-shadow: 0 0 12px rgba(198, 232, 232, 0.8); }
        .achievement.founded.rare::after { background: #EE7430; box-shadow: 0 0 12px rgba(238, 116, 48, 0.8); }
        .achievement.founded.common::after { background: #19D0EA; box-shadow: 0 0 12px rgba(25, 208, 234, 0.8); }

        /* unlocked bg tint */
        .achievement.unlocked {
            background: rgba(198, 232, 232, 0.08);
            border-color: rgba(198, 232, 232, 0.25);
        }
        /* founder bg + COSMIC ANIMATIONS */
        .achievement.founded {
            background: rgba(198, 232, 232, 0.12);
            border-color: rgba(198, 232, 232, 0.4);
            box-shadow: 0 0 18px rgba(198, 232, 232, 0.2);
            animation: founderPulse 3s ease-in-out infinite;
        }
        /* Rare founder (top 5%) - ORANGE */
        .achievement.founded.rare {
            background: rgba(238, 116, 48, 0.12);
            border-color: rgba(238, 116, 48, 0.5);
            box-shadow: 0 0 18px rgba(238, 116, 48, 0.3);
            animation: founderPulseOrange 3s ease-in-out infinite;
        }
        /* Common founder (bottom 95%) - BRIGHT CYAN */
        .achievement.founded.common {
            background: rgba(25, 208, 234, 0.12);
            border-color: rgba(25, 208, 234, 0.5);
            box-shadow: 0 0 18px rgba(25, 208, 234, 0.3);
            animation: founderPulseCyan 3s ease-in-out infinite;
        }
        @keyframes founderPulse {
            0%, 100% { box-shadow: 0 0 18px rgba(198, 232, 232, 0.2); }
            50%      { box-shadow: 0 0 28px rgba(198, 232, 232, 0.4), 0 0 40px rgba(198, 232, 232, 0.15); }
        }
        @keyframes founderPulseOrange {
            0%, 100% { box-shadow: 0 0 18px rgba(238, 116, 48, 0.3); }
            50%      { box-shadow: 0 0 32px rgba(238, 116, 48, 0.5), 0 0 48px rgba(238, 116, 48, 0.2); }
        }
        @keyframes founderPulseCyan {
            0%, 100% { box-shadow: 0 0 18px rgba(25, 208, 234, 0.3); }
            50%      { box-shadow: 0 0 32px rgba(25, 208, 234, 0.5), 0 0 48px rgba(25, 208, 234, 0.2); }
        }
        /* Founder shimmer overlay */
        .achievement.founded::before {
            background: linear-gradient(
                120deg,
                transparent 20%,
                rgba(198, 232, 232, 0.2) 40%,
                rgba(224, 245, 245, 0.3) 50%,
                rgba(198, 232, 232, 0.2) 60%,
                transparent 80%
            );
            animation: founderShimmer 4s ease-in-out infinite;
        }
        .achievement.founded.rare::before {
            background: linear-gradient(
                120deg,
                transparent 20%,
                rgba(238, 116, 48, 0.25) 40%,
                rgba(255, 140, 70, 0.35) 50%,
                rgba(238, 116, 48, 0.25) 60%,
                transparent 80%
            );
        }
        .achievement.founded.common::before {
            background: linear-gradient(
                120deg,
                transparent 20%,
                rgba(25, 208, 234, 0.25) 40%,
                rgba(60, 225, 245, 0.35) 50%,
                rgba(25, 208, 234, 0.25) 60%,
                transparent 80%
            );
        }
        @keyframes founderShimmer {
            0%   { transform: translateX(-150%); }
            50%  { transform: translateX(150%); }
            100% { transform: translateX(-150%); }
        }
        .achievement.unlocked:hover { border-color: rgba(198, 232, 232, 0.6); }
        .achievement.founded:hover  {
            border-color: rgba(224, 245, 245, 0.7);
            box-shadow: 0 0 32px rgba(198, 232, 232, 0.4), 0 8px 24px rgba(0,0,0,0.4);
        }
        .achievement.founded.rare:hover {
            border-color: rgba(238, 116, 48, 0.8);
            box-shadow: 0 0 36px rgba(238, 116, 48, 0.6), 0 8px 24px rgba(0,0,0,0.4);
        }
        .achievement.founded.common:hover {
            border-color: rgba(25, 208, 234, 0.8);
            box-shadow: 0 0 36px rgba(25, 208, 234, 0.6), 0 8px 24px rgba(0,0,0,0.4);
        }

        .ach-header {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-left: 8px;
        }
        .ach-icon {
            width: 34px; height: 34px;
            border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.15rem;
            flex-shrink: 0;
            background: rgba(37, 36, 36, 0.6);
            border: 1px solid var(--border);
        }
        .achievement.unlocked .ach-icon {
            background: rgba(198, 232, 232, 0.15);
            border-color: rgba(198, 232, 232, 0.3);
        }
        .achievement.founded .ach-icon {
            background: rgba(198, 232, 232, 0.2);
            border-color: rgba(198, 232, 232, 0.4);
            box-shadow: 0 0 8px rgba(198, 232, 232, 0.3);
        }
        .achievement.founded.rare .ach-icon {
            background: rgba(238, 116, 48, 0.2);
            border-color: rgba(238, 116, 48, 0.5);
            box-shadow: 0 0 10px rgba(238, 116, 48, 0.4);
        }
        .achievement.founded.common .ach-icon {
            background: rgba(25, 208, 234, 0.2);
            border-color: rgba(25, 208, 234, 0.5);
            box-shadow: 0 0 10px rgba(25, 208, 234, 0.4);
        }

        .ach-title-wrap { flex: 1; min-width: 0; }
        .ach-name {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text);
            line-height: 1.2;
            letter-spacing: 0.02em;
        }
        .achievement.unlocked .ach-name { color: var(--cyan-bright); }
        .achievement.founded  .ach-name {
            color: var(--cyan-bright);
            text-shadow: 0 0 8px rgba(198, 232, 232, 0.4);
        }

        .ach-badges {
            display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap;
        }
        .ach-badge {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            padding: 1px 6px;
            border-radius: 99px;
            letter-spacing: 0.05em;
            font-weight: 400;
        }
        .badge-earned  {
            background: rgba(198, 232, 232, 0.15);
            color: var(--cyan-bright);
            border: 1px solid rgba(198, 232, 232, 0.3);
        }
        .badge-founder {
            background: rgba(224, 245, 245, 0.2);
            color: var(--cyan-bright);
            border: 1px solid rgba(198, 232, 232, 0.4);
            box-shadow: 0 0 4px rgba(198, 232, 232, 0.3);
        }
        .badge-founder.rare {
            background: rgba(238, 116, 48, 0.2);
            color: #ff9f6b;
            border: 1px solid rgba(238, 116, 48, 0.5);
            box-shadow: 0 0 6px rgba(238, 116, 48, 0.4);
        }
        .badge-founder.common {
            background: rgba(25, 208, 234, 0.2);
            color: #4de5ff;
            border: 1px solid rgba(25, 208, 234, 0.5);
            box-shadow: 0 0 6px rgba(25, 208, 234, 0.4);
        }
        .badge-locked  {
            background: rgba(100,100,120,0.15);
            color: var(--muted);
            border: 1px solid rgba(198, 232, 232, 0.1);
        }
        .badge-rarity  {
            background: rgba(198, 232, 232, 0.1);
            color: var(--cyan);
            border: 1px solid rgba(198, 232, 232, 0.25);
        }
        .badge-rarity.rare {
            background: rgba(255, 215, 0, 0.15);
            color: #ffd700;
            border: 1px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
            animation: goldPulse 2s ease-in-out infinite;
        }
        @keyframes goldPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(255, 215, 0, 0.4); }
            50%      { box-shadow: 0 0 12px rgba(255, 215, 0, 0.6), 0 0 16px rgba(255, 215, 0, 0.3); }
        }

        .ach-desc {
            font-size: 0.9rem;
            color: var(--muted);
            margin-top: 10px;
            margin-left: 8px;
            line-height: 1.5;
            font-weight: 500;
        }
        
        /* Spacer to push expand button to bottom */
        .ach-spacer {
            flex: 1;
        }

        .ach-meta {
            margin-top: 12px;
            margin-left: 8px;
            padding-top: 10px;
            border-top: 1px solid rgba(198, 232, 232, 0.1);
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        .ach-meta-row {
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            color: var(--muted);
        }
        .ach-meta-row .dot {
            width: 5px; height: 5px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .dot-cyan  { background: var(--cyan); box-shadow: 0 0 4px rgba(198, 232, 232, 0.6); }
        .dot-bright { background: var(--cyan-bright); box-shadow: 0 0 6px rgba(224, 245, 245, 0.8); }
        .dot-gray  { background: rgba(198, 232, 232, 0.2); }

        /* ── EXPANDABLE RECENT USERS ── */
        .ach-expand-btn {
            margin: 8px 0 0 0;
            padding: 8px 0;
            background: transparent;
            border: none;
            border-top: 1px solid rgba(198, 232, 232, 0.1);
            color: var(--cyan);
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        .ach-expand-btn:hover {
            color: var(--cyan-bright);
        }
        .ach-expand-btn .arrow {
            transition: transform 0.2s;
            font-size: 0.6rem;
        }
        .achievement.expanded .ach-expand-btn .arrow {
            transform: rotate(180deg);
        }
        
        .ach-recent-users {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            margin: 0 8px;
        }
        .achievement.expanded .ach-recent-users {
            max-height: 300px;
        }
        .ach-recent-title {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--muted);
            letter-spacing: 0.05em;
            margin: 12px 0 8px 0;
            text-transform: uppercase;
        }
        .recent-user-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: rgba(198, 232, 232, 0.05);
            border-radius: 6px;
            margin-bottom: 4px;
            border: 1px solid rgba(198, 232, 232, 0.1);
            transition: all 0.2s;
        }
        .recent-user-item:hover {
            background: rgba(198, 232, 232, 0.1);
            border-color: rgba(198, 232, 232, 0.2);
        }
        .recent-user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--cyan), var(--cyan-dim));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 700;
            color: #1B1A1A;
            flex-shrink: 0;
        }
        .recent-user-info {
            flex: 1;
            min-width: 0;
        }
        .recent-user-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .recent-user-date {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: var(--muted);
        }

        /* ── EMPTY STATE ── */
        .empty-state {
            grid-column: 1 / -1;
            text-align: center;
            padding: 60px 20px;
            color: var(--muted);
        }
        .empty-state .icon { font-size: 2.5rem; margin-bottom: 12px; }
        .empty-state p { font-size: 1rem; font-weight: 500; }
        .empty-state small { font-size: 0.85rem; margin-top: 4px; display: block; }

        /* ── STATUS BAR ── */
        #statusBar {
            font-family: 'Space Mono', monospace;
            font-size: 0.72rem;
            color: var(--muted);
            letter-spacing: 0.06em;
            padding-left: 4px;
            min-height: 1.2em;
        }

        /* ── TOAST ── */
        #toast {
            position: fixed;
            bottom: 28px; left: 50%;
            transform: translateX(-50%) translateY(80px);
            background: rgba(37, 36, 36, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text);
            z-index: 100;
            transition: transform 0.3s cubic-bezier(.4,0,.2,1), opacity 0.3s;
            opacity: 0;
            pointer-events: none;
            white-space: nowrap;
            box-shadow: 0 4px 24px rgba(0,0,0,0.6);
        }
        #toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        #toast.error { border-color: #ff6b6b; color: #ff9999; }
        #toast.gold { 
            border-color: var(--gold); 
            color: var(--gold);
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            font-weight: 700;
        }
        #toast.founder-toast {
            border-color: #19D0EA;
            color: #19D0EA;
            box-shadow: 0 0 24px rgba(25, 208, 234, 0.5), 0 4px 24px rgba(0,0,0,0.6);
            animation: founderToastGlow 2s ease-in-out infinite;
        }
        @keyframes founderToastGlow {
            0%, 100% { box-shadow: 0 0 24px rgba(25, 208, 234, 0.5), 0 4px 24px rgba(0,0,0,0.6); }
            50%      { box-shadow: 0 0 36px rgba(25, 208, 234, 0.8), 0 4px 24px rgba(0,0,0,0.6); }
        }

        /* ── STAR GAME BUTTON ── */
        .star-game-btn {
            position: fixed;
            bottom: 28px;
            right: 28px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: rgba(27, 26, 26, 0.9);
            border: 2px solid var(--cyan);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 99;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(198, 232, 232, 0.4), 0 4px 12px rgba(0,0,0,0.5);
        }
        .star-game-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(198, 232, 232, 0.6), 0 4px 12px rgba(0,0,0,0.5);
        }
        .star-game-btn svg {
            width: 28px;
            height: 28px;
        }
        
        /* Game mode - hide UI */
        body.star-game-active #appContent,
        body.star-game-active #toast {
            opacity: 0;
            pointer-events: none;
        }
        body.save-stars-active #appContent,
        body.save-stars-active #toast {
            opacity: 0;
            pointer-events: none;
        }
        body.star-game-active #toast.gold {
            opacity: 1 !important;
            pointer-events: auto;
            z-index: 150;
        }
        body.save-stars-active #toast {
            opacity: 1 !important;
            pointer-events: auto;
            z-index: 150;
        }
        body.star-game-active .star-game-btn {
            background: rgba(27, 26, 26, 0.95);
            border-color: #ff6b6b;
        }
        
        /* Star game score display */
        .star-game-score {
            position: fixed;
            top: 28px;
            right: 28px;
            background: rgba(27, 26, 26, 0.95);
            border: 2px solid var(--cyan);
            border-radius: 12px;
            padding: 16px 24px;
            font-family: 'Space Mono', monospace;
            color: var(--cyan);
            z-index: 99;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            box-shadow: 0 0 20px rgba(198, 232, 232, 0.4);
        }
        body.star-game-active .star-game-score {
            opacity: 1;
        }
        .star-game-score .score {
            font-size: 2rem;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(198, 232, 232, 0.6);
            transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .star-game-score .score.pop {
            transform: scale(1.3);
        }
        .star-game-score .label {
            font-size: 0.7rem;
            color: var(--muted);
            margin-top: 4px;
            transition: color 0.3s;
        }
        .star-game-score .label.danger {
            color: #ff6b6b;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .star-game-score .record {
            font-size: 0.65rem;
            color: var(--gold);
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
        }
        
        /* Game Over Modal */
        .game-over-modal {
            position: fixed;
            inset: 0;
            background: rgba(27, 26, 26, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(8px);
        }
        .game-over-modal.visible {
            display: flex;
        }
        .game-over-content {
            background: rgba(37, 36, 36, 0.95);
            border: 2px solid var(--cyan);
            border-radius: 16px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px rgba(198, 232, 232, 0.6);
            font-family: 'Space Mono', monospace;
            text-align: center;
        }
        .game-over-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--cyan);
            margin-bottom: 16px;
            text-shadow: 0 0 12px rgba(198, 232, 232, 0.6);
        }
        .game-over-score {
            font-size: 3.5rem;
            font-weight: 700;
            color: var(--cyan-bright);
            margin: 12px 0;
            text-shadow: 0 0 16px rgba(198, 232, 232, 0.8);
        }
        .game-over-label {
            font-size: 0.7rem;
            color: var(--muted);
            letter-spacing: 0.15em;
            margin-bottom: 24px;
        }
        .game-over-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin: 24px 0;
            padding: 20px 0;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }
        @media (max-width: 600px) {
            .game-over-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        .game-over-stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--cyan);
        }
        .stat-label {
            font-size: 0.7rem;
            color: var(--text);
            font-weight: 600;
        }
        .stat-subtext {
            font-size: 0.6rem;
            color: var(--muted);
        }
        .game-over-record {
            font-size: 0.85rem;
            color: var(--gold);
            margin: 16px 0;
            min-height: 20px;
        }
        .game-over-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-top: 24px;
        }
        @media (max-width: 600px) {
            .game-over-buttons {
                grid-template-columns: 1fr;
            }
        }
        .game-over-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 0.05em;
        }
        .game-over-btn-primary {
            background: var(--cyan);
            color: #1B1A1A;
            box-shadow: 0 0 16px rgba(198, 232, 232, 0.4);
        }
        .game-over-btn-primary:hover {
            background: var(--cyan-bright);
            box-shadow: 0 0 24px rgba(198, 232, 232, 0.6);
            transform: translateY(-2px);
        }
        .game-over-btn-secondary {
            background: transparent;
            color: var(--muted);
            border: 1px solid var(--border);
        }
        .game-over-btn-secondary:hover {
            color: var(--text);
            border-color: var(--cyan);
        }
        .game-over-warning {
            font-size: 0.6rem;
            color: rgba(198, 232, 232, 0.3);
            margin-top: 20px;
            font-style: italic;
        }
        
        /* Cheat Warning Modal */
        .cheat-warning-modal {
            position: fixed;
            inset: 0;
            background: rgba(27, 26, 26, 0.98);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 101;
            backdrop-filter: blur(10px);
        }
        .cheat-warning-modal.visible {
            display: flex;
        }
        .cheat-warning-content {
            background: rgba(37, 36, 36, 0.95);
            border: 2px solid #ff6b6b;
            border-radius: 16px;
            padding: 40px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 0 40px rgba(255, 107, 107, 0.5);
            font-family: 'Space Mono', monospace;
            text-align: center;
        }
        .cheat-warning-emoji {
            font-size: 4rem;
            margin-bottom: 20px;
        }
        .cheat-warning-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ff6b6b;
            margin-bottom: 16px;
        }
        .cheat-warning-text {
            font-size: 1rem;
            color: var(--text);
            margin-bottom: 12px;
        }
        .cheat-warning-subtext {
            font-size: 0.85rem;
            color: var(--muted);
            margin-bottom: 24px;
        }
        
        /* Mode Select Modal */
        .mode-select-modal {
            position: fixed;
            inset: 0;
            background: rgba(27, 26, 26, 0.98);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 102;
            backdrop-filter: blur(10px);
            overflow-y: auto;
            padding: 20px;
        }
        .mode-select-modal.visible {
            display: flex;
        }
        .mode-select-content {
            background: rgba(37, 36, 36, 0.95);
            border: 2px solid var(--cyan);
            border-radius: 16px;
            padding: 32px;
            max-width: 700px;
            width: 95%;
            box-shadow: 0 0 40px rgba(198, 232, 232, 0.6);
            margin: auto;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        .mode-select-settings-btn {
            position: absolute;
            top: 16px;
            left: 16px;
            width: 40px;
            height: 40px;
            background: rgba(198, 232, 232, 0.1);
            border: 1px solid rgba(198, 232, 232, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mode-select-settings-btn svg {
            width: 20px;
            height: 20px;
            color: var(--cyan);
        }
        .mode-select-settings-btn:hover {
            background: rgba(198, 232, 232, 0.2);
            border-color: var(--cyan);
            transform: rotate(90deg);
        }
        .mode-select-title {
            font-family: 'Space Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--cyan);
            text-align: center;
            margin-bottom: 24px;
            text-shadow: 0 0 12px rgba(198, 232, 232, 0.6);
        }
        .mode-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }
        @media (max-width: 600px) {
            .mode-grid {
                grid-template-columns: 1fr;
            }
        }
        .mode-card {
            position: relative;
            background: rgba(45, 44, 44, 0.8);
            border: 2px solid rgba(198, 232, 232, 0.3);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .mode-card:hover:not(.locked) {
            border-color: var(--cyan);
            background: rgba(45, 44, 44, 1);
            transform: translateY(-4px);
            box-shadow: 0 0 20px rgba(198, 232, 232, 0.4);
        }
        .mode-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .mode-lock {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 1.2rem;
        }
        .mode-icon {
            font-size: 2.5rem;
            margin-bottom: 12px;
        }
        .mode-name {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--cyan);
            margin-bottom: 8px;
        }
        .mode-desc {
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            color: var(--text);
            margin-bottom: 8px;
        }
        .mode-unlock {
            font-size: 0.65rem;
            color: var(--muted);
            font-style: italic;
        }
        .mode-highscore {
            font-size: 0.7rem;
            color: var(--cyan);
            margin-top: 8px;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(198, 232, 232, 0.6);
        }
        .mode-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px;
            background: rgba(198, 232, 232, 0.1);
            border-radius: 8px;
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--muted);
        }
        .mode-info-icon {
            font-size: 1rem;
        }
        
        /* Accessibility Notice Modal */
        .accessibility-notice-modal {
            position: fixed;
            inset: 0;
            background: rgba(27, 26, 26, 0.98);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 103;
            backdrop-filter: blur(10px);
        }
        .accessibility-notice-modal.visible {
            display: flex;
        }
        .accessibility-notice-content {
            background: rgba(37, 36, 36, 0.95);
            border: 2px solid var(--cyan);
            border-radius: 16px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px rgba(198, 232, 232, 0.6);
            font-family: 'Space Mono', monospace;
        }
        .accessibility-notice-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--cyan);
            margin-bottom: 20px;
            text-align: center;
        }
        .accessibility-notice-text {
            font-size: 0.95rem;
            color: var(--text);
            margin-bottom: 16px;
            line-height: 1.6;
        }
        .accessibility-notice-highlight {
            background: rgba(198, 232, 232, 0.15);
            border-left: 3px solid var(--cyan);
            padding: 12px 16px;
            font-size: 0.9rem;
            color: var(--text);
            margin-bottom: 16px;
            line-height: 1.5;
            border-radius: 4px;
        }
        .accessibility-notice-highlight strong {
            color: var(--cyan);
        }
        .accessibility-notice-footer {
            font-size: 0.8rem;
            color: var(--muted);
            text-align: center;
            margin-bottom: 20px;
            font-style: italic;
        }
        
        /* Accessibility Settings Modal */
        .accessibility-settings-modal {
            position: fixed;
            inset: 0;
            background: rgba(27, 26, 26, 0.98);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 103;
            backdrop-filter: blur(10px);
        }
        .accessibility-settings-modal.visible {
            display: flex;
        }
        .accessibility-settings-content {
            background: rgba(37, 36, 36, 0.95);
            border: 2px solid var(--cyan);
            border-radius: 16px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px rgba(198, 232, 232, 0.6);
            font-family: 'Space Mono', monospace;
        }
        .accessibility-settings-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--cyan);
            margin-bottom: 24px;
            text-align: center;
        }
        .accessibility-setting-group {
            margin-bottom: 24px;
        }
        .accessibility-setting-label {
            font-size: 1rem;
            font-weight: 700;
            color: var(--cyan);
            margin-bottom: 12px;
        }
        .accessibility-radio-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
        }
        .accessibility-radio {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        .accessibility-radio:hover {
            background: rgba(198, 232, 232, 0.1);
        }
        .accessibility-radio input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .accessibility-radio span {
            font-size: 0.9rem;
            color: var(--text);
        }
        .accessibility-description {
            font-size: 0.75rem;
            color: var(--muted);
            line-height: 1.5;
            padding: 12px;
            background: rgba(198, 232, 232, 0.05);
            border-radius: 8px;
        }
        
        /* Konami Modal */
        .konami-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            backdrop-filter: blur(15px);
        }
        .konami-modal.visible {
            display: flex;
            animation: konamiFadeIn 0.5s ease-out;
        }
        @keyframes konamiFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .konami-content {
            text-align: center;
            padding: 60px 40px;
        }
        .konami-title {
            font-family: 'Space Mono', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--cyan);
            margin-bottom: 40px;
            text-shadow: 0 0 20px rgba(198, 232, 232, 0.8);
            animation: konamiPulse 2s ease-in-out infinite;
        }
        @keyframes konamiPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .konami-start-btn {
            font-size: 1.5rem;
            padding: 20px 50px;
            animation: konamiGlow 1.5s ease-in-out infinite;
        }
        @keyframes konamiGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(198, 232, 232, 0.4); }
            50% { box-shadow: 0 0 40px rgba(198, 232, 232, 0.8); }
        }
        
        /* Save the Stars UI */
        .save-stars-ui {
            position: fixed;
            top: 20px;
            right: 20px;
            display: none;
            flex-direction: column;
            gap: 12px;
            z-index: 90;
            pointer-events: none;
        }
        body.save-stars-active .save-stars-ui {
            display: flex;
        }
        .save-stars-stat {
            background: rgba(37, 36, 36, 0.9);
            border: 2px solid var(--cyan);
            border-radius: 12px;
            padding: 12px 20px;
            text-align: center;
            min-width: 120px;
        }
        .save-stars-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--cyan);
            margin-bottom: 4px;
        }
        .save-stars-value {
            font-family: 'Space Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            color: var(--text);
        }

        /* ── MOBILE ── */
        @media (max-width: 520px) {
            .page-wrap { padding: 20px 14px 48px; gap: 20px; }
            #achievementsContainer { grid-template-columns: 1fr; }
            .search-row { flex-direction: column; }
            .btn { width: 100%; }
        }
    </style>
</head>
<body>

<!-- CONSTELLATION CANVAS -->
<canvas id="constellation"></canvas>

<!-- LOADING SCREEN -->
<div id="loadingScreen">
    <div class="loading-title">⬡ Achievements</div>
    <div class="loading-bar-wrap">
        <div class="loading-bar-fill" id="loadingBarFill"></div>
    </div>
    <div id="loadingStatus">Initializing…</div>
</div>

<!-- MAIN APP (hidden until loaded) -->
<div id="appContent">
<div class="page-wrap">

    <!-- HEADER -->
    <header>
        <div class="eyebrow">⬡ Cosmic Playground</div>
        <h1>Achievements</h1>
        <p class="subtitle">Track your progress across time</p>
    </header>

    <!-- LEADERBOARD -->
    <div class="leaderboard" id="leaderboard">
        <div class="leaderboard-timer-label" id="leaderboardTimerLabel">Keep Open</div>
        <div class="leaderboard-timer" id="leaderboardTimer">
            <div class="leaderboard-timer-fill" id="leaderboardTimerFill"></div>
        </div>
        <div class="leaderboard-header" id="leaderboardHeader">
            <div class="leaderboard-title">⭐ Top Achievers ⭐</div>
            <div class="leaderboard-toggle">▼</div>
        </div>
        <div class="leaderboard-content">
            <div class="leaderboard-grid" id="leaderboardGrid">
                <!-- Built by JS -->
            </div>
        </div>
    </div>

    <!-- SEARCH -->
    <div class="search-card">
        <div class="search-row">
            <div class="input-wrap">
                <span class="icon">⌕</span>
                <input id="userIdInput" type="text" placeholder="Enter username or ID…" autocomplete="off" spellcheck="false">
                <div id="autocomplete"></div>
            </div>
            <button class="btn btn-primary" id="loadBtn">Search</button>
            <button class="btn btn-ghost" id="showAllBtn">All</button>
        </div>
        <div id="profileBanner">
            <div class="avatar" id="avatarEl">?</div>
            <div class="profile-info">
                <div class="profile-name" id="profileName">—</div>
                <div class="profile-stats" id="profileStats">0 earned</div>
                <div class="progress-bar-wrap">
                    <div class="progress-bar-fill" id="progressFill" style="width:0%"></div>
                </div>
            </div>
            <button class="btn-claim" id="claimBtn" title="Save as my profile">This is me!</button>
            <button class="btn-clear" id="clearBtn" title="Clear user">✕</button>
        </div>
    </div>

    <!-- TABS -->
    <div class="tabs-wrap">
        <div class="tabs-header" id="tabsHeader"><!-- built by JS --></div>
        
        <!-- FILTER ROW (only when user loaded) -->
        <div class="filter-row" id="filterRow">
            <span class="control-label">SHOW:</span>
            <button class="filter-chip active" data-filter="all">All</button>
            <button class="filter-chip" data-filter="unlocked">Earned</button>
            <button class="filter-chip" data-filter="founder">Founder</button>
        </div>
        
        <!-- SORT ROW (always visible) -->
        <div class="sort-row">
            <span class="control-label">SORT:</span>
            <select class="sort-select" id="sortSelect">
                <!-- options built by JS based on context -->
            </select>
        </div>
        
        <div id="statusBar"></div>
    </div>

    <!-- ACHIEVEMENT GRID -->
    <div id="achievementsContainer"></div>

</div>
</div><!-- /appContent -->

<!-- TOAST -->
<div id="toast"></div>

<!-- STAR GAME BUTTON -->
<button class="star-game-btn" id="starGameBtn" title="Star Hunt Game">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="12,2 15,9 22,9 17,14 19,21 12,17 5,21 7,14 2,9 9,9" fill="rgba(198, 232, 232, 0.2)" stroke="#C6E8E8"/>
    </svg>
</button>

<!-- STAR GAME SCORE -->
<div class="star-game-score" id="starGameScore">
    <div class="score" id="gameScore">0</div>
    <div class="label">STARS COLLECTED</div>
    <div class="record" id="gameRecord">Record: 0</div>
</div>

<!-- SAVE THE STARS UI -->
<div class="save-stars-ui" id="saveStarsUI">
    <div class="save-stars-stat">
        <div class="save-stars-label">❤️ HP</div>
        <div id="saveStarsHP" class="save-stars-value">100</div>
    </div>
    <div class="save-stars-stat">
        <div class="save-stars-label">⏱️ TIME</div>
        <div id="saveStarsTime" class="save-stars-value">0</div>
    </div>
</div>

<!-- GAME OVER MODAL -->
<div class="game-over-modal" id="gameOverModal">
    <div class="game-over-content">
        <div class="game-over-title">Game Over!</div>
        <div class="game-over-score" id="gameOverScore">0</div>
        <div class="game-over-label">FINAL SCORE</div>
        
        <div class="game-over-stats">
            <div class="game-over-stat">
                <div class="stat-value" id="statRegular">0</div>
                <div class="stat-label">Standard Stars</div>
                <div class="stat-subtext">1 pt each</div>
            </div>
            <div class="game-over-stat">
                <div class="stat-value" id="statTwinkle">0</div>
                <div class="stat-label">Twinkle Stars</div>
                <div class="stat-subtext">2 pts each</div>
            </div>
            <div class="game-over-stat">
                <div class="stat-value" id="statBonus">0</div>
                <div class="stat-label">Bonus Stars</div>
                <div class="stat-subtext">5 pts each</div>
            </div>
            <div class="game-over-stat">
                <div class="stat-value" id="statComet">0</div>
                <div class="stat-label">Comets</div>
                <div class="stat-subtext">15 pts each</div>
            </div>
        </div>
        
        <div class="game-over-record" id="gameOverRecord"></div>
        
        <div class="game-over-buttons">
            <button class="game-over-btn game-over-btn-primary" id="tryAgainBtn">Try Again</button>
            <button class="game-over-btn game-over-btn-secondary" id="changeModeBtn">Change Mode</button>
            <button class="game-over-btn game-over-btn-secondary" id="closeGameBtn">Close</button>
        </div>
        
        <div class="game-over-warning">⚠ Game data stored locally in browser</div>
    </div>
</div>

<!-- CHEAT WARNING MODAL -->
<div class="cheat-warning-modal" id="cheatWarningModal">
    <div class="cheat-warning-content">
        <div class="cheat-warning-emoji">😔</div>
        <div class="cheat-warning-title">Hey, not cool man :(</div>
        <div class="cheat-warning-text">Don't use auto-clickers or macros!</div>
        <div class="cheat-warning-subtext">Play fair and have fun 🌟</div>
        <button class="game-over-btn game-over-btn-primary" id="cheatOkBtn">I'll play fair!</button>
    </div>
</div>

<!-- MODE SELECT MODAL -->
<div class="mode-select-modal" id="modeSelectModal">
    <div class="mode-select-content">
        <button class="mode-select-settings-btn" id="modeSelectSettingsBtn" title="Accessibility Settings">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 1v6m0 6v6m0-18a2 2 0 0 1 2 2v16a2 2 0 0 1-4 0V3a2 2 0 0 1 2-2z"></path>
                <path d="m19.14 4.93-4.24 4.24m0 5.66 4.24 4.24M4.86 4.93l4.24 4.24m0 5.66-4.24 4.24"></path>
            </svg>
        </button>
        <div class="mode-select-title">Select Game Mode</div>
        
        <div class="mode-grid">
            <button class="mode-card" data-mode="normal">
                <div class="mode-icon">⭐</div>
                <div class="mode-name">Normal</div>
                <div class="mode-desc">All star types, 60 seconds</div>
            </button>
            
            <button class="mode-card" data-mode="twinkle" id="modeTwinkle">
                <div class="mode-lock" id="lockTwinkle">🔒</div>
                <div class="mode-icon">✨</div>
                <div class="mode-name">Twinkle Twinkle</div>
                <div class="mode-desc">Only cyan stars spawn</div>
                <div class="mode-unlock">Unlock: Get 20 bonus stars in one game</div>
            </button>
            
            <button class="mode-card" data-mode="comet" id="modeComet">
                <div class="mode-lock" id="lockComet">🔒</div>
                <div class="mode-icon">🌠</div>
                <div class="mode-name">Comet Rush</div>
                <div class="mode-desc">Comets everywhere!</div>
                <div class="mode-unlock">Unlock: Catch 3 comets in one game</div>
            </button>
            
            <button class="mode-card" data-mode="starclear" id="modeStarclear">
                <div class="mode-lock" id="lockStarclear">🔒</div>
                <div class="mode-icon">🌌</div>
                <div class="mode-name">Star Clear</div>
                <div class="mode-desc">Clear TONS of stars!</div>
                <div class="mode-unlock">Unlock: Collect 150 stars in one game</div>
            </button>
        </div>
        
        <div class="mode-info">
            <span class="mode-info-icon">ℹ️</span>
            <span class="mode-info-text">Complete challenges in Normal mode to unlock new modes!</span>
        </div>
    </div>
</div>

<!-- ACCESSIBILITY NOTICE MODAL -->
<div class="accessibility-notice-modal" id="accessibilityNoticeModal">
    <div class="accessibility-notice-content">
        <div class="accessibility-notice-title">Hey! Quick heads up 👋</div>
        <div class="accessibility-notice-text">
            This game involves a lot of clicking. If that's tough on your hands or joints, 
            I've added some options in the settings to help out!
        </div>
        <div class="accessibility-notice-highlight">
            <strong>Spacebar Click</strong>: lets you press space to click, which is way easier on your hands. 
        </div>
        <div class="accessibility-notice-highlight">
            <strong>Always on</strong>: a mode that auto-clicks for you, but fair warning: it makes the game pretty easy. 
        </div>
        <div class="accessibility-notice-footer">
            You can change these anytime from the icon in the game menu.
        </div>
        <button class="game-over-btn game-over-btn-primary" id="accessibilityOkBtn">Got it, thanks!</button>
    </div>
</div>

<!-- ACCESSIBILITY SETTINGS MODAL -->
<div class="accessibility-settings-modal" id="accessibilitySettingsModal">
    <div class="accessibility-settings-content">
        <div class="accessibility-settings-title">♿ Accessibility Settings</div>
        
        <div class="accessibility-setting-group">
            <div class="accessibility-setting-label">Click Mode:</div>
            <div class="accessibility-radio-group">
                <label class="accessibility-radio">
                    <input type="radio" name="accessMode" value="none" checked>
                    <span>Mouse Only (Default)</span>
                </label>
                <label class="accessibility-radio">
                    <input type="radio" name="accessMode" value="spacebar">
                    <span>Spacebar Click (Recommended)</span>
                </label>
                <label class="accessibility-radio">
                    <input type="radio" name="accessMode" value="alwayson">
                    <span>Always On Cursor (Easy Mode)</span>
                </label>
            </div>
            <div class="accessibility-description">
                <strong>Spacebar:</strong> Press space to click at cursor position. Saves your clicking hand!<br>
                <strong>Always On:</strong> Automatically clicks stars near your cursor. Much easier!
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 16px; font-size: 0.75rem; color: var(--muted); font-style: italic;">
            PS: Old school gamers might find something extra here... 🎮
        </div>
        
        <button class="game-over-btn game-over-btn-primary" id="saveAccessibilityBtn">Save Settings</button>
    </div>
</div>

<!-- KONAMI CODE MODAL -->
<div class="konami-modal" id="konamiModal">
    <div class="konami-content">
        <div class="konami-title">You're asking for it now huh...</div>
        <button class="game-over-btn game-over-btn-primary konami-start-btn" id="konamiStartBtn">
            Start / Select!
        </button>
    </div>
</div>

<script>
// ── CONSTELLATION BACKGROUND ──────────────────────────────────────────
const TWINKLING_STARS_COUNT = 30; // Adjust this to control how many twinkling stars

// ── STAR GAME STATE ───────────────────────────────────────────────────
let starGameActive = false;
let starGameScore = 0;
let modeRecords = getCookie('starGameModeRecords') || { normal: 0, twinkle: 0, comet: 0, starclear: 0 };
let fastTwinklers = []; // 5-point fast stars
let starGameTimeLeft = 60; // 60 second timer
let starGameTimerInterval = null;
let starGameStats = { regular: 0, twinkle: 0, bonus: 0, comet: 0 }; // Track star types collected
let particles = []; // Particle effects for star collection
let clickTimes = []; // Track click timestamps for anti-cheat
const MAX_CPS = 10; 
let shootingStar = null; // Shooting star object
let shootingStars = []; // Array of shooting stars for comet rush mode
let shootingStarTimer = null; // Timer for spawning shooting stars
let lastTickTime = 0; // Prevent tick from playing too frequently
let gameMode = 'normal'; // Current game mode
let accessibilitySettings = getCookie('accessibilitySettings') || { mode: 'none', shownNotice: false };

// Save the Stars mode variables
let saveStarsActive = false;
let blackHoles = [];
let redBlackHoles = [];
let playerHP = 500;
let survivalTime = 0;
let saveStarsTimer = null;
let saveStarsInterval = null;
let blackHoleSpawnTimer = null;
let nextBlackHoleDelay = 1500; // Start at 1.5 seconds

const canvas = document.getElementById('constellation');
const ctx = canvas.getContext('2d');

let stars = [];
let twinklingStars = [];
let mouse = { x: null, y: null };
let w, h;

function initConstellation() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    
    // Create stars
    stars = [];
    let starCount;
    if (gameMode === 'starclear') {
        starCount = Math.floor((w * h) / 2000); // 4x more stars in star clear mode!
    } else {
        starCount = Math.floor((w * h) / 8000);
    }
    
    for (let i = 0; i < starCount; i++) {
        stars.push({
            x: Math.random() * w,
            y: Math.random() * h,
            vx: (Math.random() - 0.5) * 0.3,
            vy: (Math.random() - 0.5) * 0.3,
            radius: Math.random() * 1.5 + 0.5,
            brightness: Math.random() * 0.5 + 0.5,
        });
    }
    
    // Initialize twinkling stars array
    twinklingStars = [];
}

function spawnTwinklingStar() {
    // Mode-specific spawning
    if (gameMode === 'comet') return; // No twinkle stars in comet mode
    if (gameMode === 'starclear') return; // No twinkle stars in star clear mode
    
    let isFast;
    if (gameMode === 'twinkle') {
        isFast = Math.random() < 0.3; // 30% chance in twinkle mode (more bonus stars)
    } else {
        isFast = Math.random() < 0.2; // 20% chance normally
    }
    
    const lifetime = isFast ? 2.5 : (5 + Math.random() * 5); // Fast: 2.5s, Normal: 5-10s
    const star = {
        x: Math.random() * w,
        y: Math.random() * h,
        radius: isFast ? (Math.random() * 2.5 + 2) : (Math.random() * 2 + 1), // Fast stars bigger
        lifetime: lifetime,
        age: 0,
        fadeIn: isFast ? 0.5 : 2, // Fast: 0.5s, Normal: 2s
        fadeOut: isFast ? 0.5 : 2, // Fast: 0.5s, Normal: 2s
        points: isFast ? 5 : 2,
        isFast: isFast
    };
    twinklingStars.push(star);
    if (isFast) fastTwinklers.push(star);
}

function drawConstellation() {
    ctx.clearRect(0, 0, w, h);
    
    // Draw connections first (skip on mobile during game mode for performance)
    const isMobile = window.innerWidth < 768;
    const skipConnections = isMobile && starGameActive;
    
    if (!skipConnections) {
        ctx.strokeStyle = 'rgba(198, 232, 232, 0.15)';
        ctx.lineWidth = 0.5;
        
        for (let i = 0; i < stars.length; i++) {
            const star = stars[i];
            
            // Connect to nearby stars
            for (let j = i + 1; j < stars.length; j++) {
                const other = stars[j];
                const dx = star.x - other.x;
                const dy = star.y - other.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 120) {
                    const opacity = (1 - dist / 120) * 0.3;
                    ctx.strokeStyle = `rgba(198, 232, 232, ${opacity})`;
                    ctx.beginPath();
                    ctx.moveTo(star.x, star.y);
                    ctx.lineTo(other.x, other.y);
                    ctx.stroke();
                }
            }
            
            // Connect to mouse if nearby
            if (mouse.x && mouse.y) {
                const dx = star.x - mouse.x;
                const dy = star.y - mouse.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 150) {
                    const opacity = (1 - dist / 150) * 0.5;
                    ctx.strokeStyle = `rgba(198, 232, 232, ${opacity})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(star.x, star.y);
                    ctx.lineTo(mouse.x, mouse.y);
                    ctx.stroke();
                    ctx.lineWidth = 0.5;
                    
                    // Pull star toward mouse gently (1/10th original force)
                    const force = (1 - dist / 150) * 0.5;
                    star.vx += (mouse.x - star.x) * force * 0.00001;
                    star.vy += (mouse.y - star.y) * force * 0.00001;
                }
            }
        }
    }
    
    // Draw permanent stars (skip in twinkle mode - only show twinkle/bonus stars)
    if (gameMode !== 'twinkle') {
        for (const star of stars) {
            // Update position
            star.x += star.vx;
            star.y += star.vy;
            
            // Damping
            star.vx *= 0.99;
            star.vy *= 0.99;
            
            // Wrap around edges
            if (star.x < 0) star.x = w;
            if (star.x > w) star.x = 0;
            if (star.y < 0) star.y = h;
            if (star.y > h) star.y = 0;
            
            // Draw star
            const alpha = star.brightness * 0.8;
            const glow = star.radius * 2;
            
            // Change color based on danger level (Save the Stars mode)
            const dangerLevel = star.danger || 0;
            const r = 198 + (255 - 198) * dangerLevel;
            const g = 232 * (1 - dangerLevel);
            const b = 232 * (1 - dangerLevel);
            
            // Glow
            const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, glow);
            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 0.8})`);
            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(star.x - glow, star.y - glow, glow * 2, glow * 2);
            
            // Core
            const coreR = 224 + (255 - 224) * dangerLevel;
            const coreG = 245 * (1 - dangerLevel);
            const coreB = 245 * (1 - dangerLevel);
            ctx.fillStyle = `rgba(${coreR}, ${coreG}, ${coreB}, ${alpha})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Update and draw twinkling stars (only in game modes)
    if (starGameActive || saveStarsActive) {
        const dt = 1/60; // Assume 60fps
        for (let i = twinklingStars.length - 1; i >= 0; i--) {
            const star = twinklingStars[i];
            star.age += dt;
            
            // Remove if expired
            if (star.age >= star.lifetime) {
                twinklingStars.splice(i, 1);
                const fastIdx = fastTwinklers.indexOf(star);
                if (fastIdx >= 0) fastTwinklers.splice(fastIdx, 1);
                continue;
            }
            
            // Calculate opacity based on age
            let alpha = 1;
            if (star.age < star.fadeIn) {
                // Fading in
                alpha = star.age / star.fadeIn;
            } else if (star.age > star.lifetime - star.fadeOut) {
                // Fading out
                alpha = (star.lifetime - star.age) / star.fadeOut;
            }
            
            // Draw twinkling star - bright cyan for fast stars, normal for regular
            const glow = star.radius * 3;
            const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, glow);
            
            if (star.isFast) {
                // Bright cyan for 5-point fast stars
                gradient.addColorStop(0, `rgba(224, 245, 245, ${alpha})`);
                gradient.addColorStop(0.5, `rgba(142, 216, 216, ${alpha * 0.7})`);
                gradient.addColorStop(1, 'rgba(198, 232, 232, 0)');
            } else {
                // Normal color for 2-point stars
                gradient.addColorStop(0, `rgba(224, 245, 245, ${alpha * 0.9})`);
                gradient.addColorStop(0.5, `rgba(198, 232, 232, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'rgba(198, 232, 232, 0)');
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(star.x - glow, star.y - glow, glow * 2, glow * 2);
            
            // Core - brighter for fast stars
            if (star.isFast) {
                ctx.fillStyle = `rgba(142, 216, 216, ${alpha})`;
            } else {
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            }
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Spawn new twinkling stars to maintain count (only in game mode)
        if (twinklingStars.length < TWINKLING_STARS_COUNT && Math.random() < 0.05) {
            spawnTwinklingStar();
        }
    }
    
    // Draw particles (only in game modes)
    if (starGameActive) {
        updateAndDrawParticles();
        updateAndDrawShootingStar();
    }
    
    // Draw Save the Stars mode
    if (saveStarsActive) {
        updateAndDrawBlackHoles();
        updateAndDrawParticles(); // Draw particles for black hole destruction
    }
    
    requestAnimationFrame(drawConstellation);
}

window.addEventListener('resize', initConstellation);
window.addEventListener('mousemove', e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
});
window.addEventListener('mouseleave', () => {
    mouse.x = null;
    mouse.y = null;
});

initConstellation();
drawConstellation();

// ── GAME MODE SELECT ──────────────────────────────────────────────────
let unlockedDuringGame = { twinkle: false, comet: false, starclear: false }; // Track what's been unlocked this session

function checkUnlocks() {
    return {
        twinkle: getCookie('twinkleUnlocked') || false,
        comet: getCookie('cometUnlocked') || false,
        starclear: getCookie('starclearUnlocked') || false
    };
}

function checkForUnlocksDuringGame() {
    // Check unlocks based on THIS game's stats (not lifetime)
    
    // Check Twinkle mode unlock (20 bonus stars in one game)
    if (!unlockedDuringGame.twinkle && !getCookie('twinkleUnlocked') && starGameStats.bonus >= 20) {
        unlockedDuringGame.twinkle = true;
        setCookie('twinkleUnlocked', true);
        playUnlockSound();
        showToast('🎉 Unlocked: Twinkle Twinkle mode! 🎉', false, 'gold');
    }
    
    // Check Comet Rush unlock (3 comets in one game)
    if (!unlockedDuringGame.comet && !getCookie('cometUnlocked') && starGameStats.comet >= 3) {
        unlockedDuringGame.comet = true;
        setCookie('cometUnlocked', true);
        playUnlockSound();
        showToast('🎉 Unlocked: Comet Rush mode! 🎉', false, 'gold');
    }
    
    // Check Star Clear unlock (150 total stars in one game)
    const totalStarsThisGame = starGameStats.regular + starGameStats.twinkle + starGameStats.bonus + starGameStats.comet;
    if (!unlockedDuringGame.starclear && !getCookie('starclearUnlocked') && totalStarsThisGame >= 150) {
        unlockedDuringGame.starclear = true;
        setCookie('starclearUnlocked', true);
        playUnlockSound();
        showToast('🎉 Unlocked: Star Clear mode! 🎉', false, 'gold');
    }
}

function showModeSelect() {
    // Show accessibility notice if first time
    if (!accessibilitySettings.shownNotice) {
        document.getElementById('accessibilityNoticeModal').classList.add('visible');
        return; // Don't show mode select yet
    }
    
    const modal = document.getElementById('modeSelectModal');
    const unlocks = checkUnlocks();
    
    // Update lock states
    document.getElementById('modeTwinkle').classList.toggle('locked', !unlocks.twinkle);
    document.getElementById('lockTwinkle').style.display = unlocks.twinkle ? 'none' : 'block';
    
    document.getElementById('modeComet').classList.toggle('locked', !unlocks.comet);
    document.getElementById('lockComet').style.display = unlocks.comet ? 'none' : 'block';
    
    document.getElementById('modeStarclear').classList.toggle('locked', !unlocks.starclear);
    document.getElementById('lockStarclear').style.display = unlocks.starclear ? 'none' : 'block';
    
    // Update high scores
    document.querySelectorAll('.mode-card').forEach(card => {
        const mode = card.dataset.mode;
        let scoreEl = card.querySelector('.mode-highscore');
        if (!scoreEl) {
            scoreEl = document.createElement('div');
            scoreEl.className = 'mode-highscore';
            card.appendChild(scoreEl);
        }
        scoreEl.textContent = `Best: ${modeRecords[mode] || 0}`;
    });
    
    modal.classList.add('visible');
}

function startGameWithMode(mode) {
    gameMode = mode;
    document.getElementById('modeSelectModal').classList.remove('visible');
    initConstellation(); // Reinitialize stars for the mode
    toggleStarGame();
}

// ── STAR GAME ─────────────────────────────────────────────────────────
function toggleStarGame() {
    starGameActive = !starGameActive;
    document.body.classList.toggle('star-game-active', starGameActive);
    
    const btn = document.getElementById('starGameBtn');
    if (starGameActive) {
        starGameScore = 0;
        starGameTimeLeft = 60;
        starGameStats = { regular: 0, twinkle: 0, bonus: 0, comet: 0 };
        clickTimes = [];
        shootingStar = null;
        shootingStars = []; // Clear comet array
        unlockedDuringGame = { twinkle: false, comet: false, starclear: false }; // Reset unlock tracking
        updateGameScore();
        showToast('⭐ Click stars to collect them! Bright cyan = 5pts ⭐', false);
        btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>`;
        btn.title = 'Exit Game';
        
        // Start countdown timer
        starGameTimerInterval = setInterval(() => {
            starGameTimeLeft--;
            
            // Play tick sound in last 10 seconds
            if (starGameTimeLeft <= 10 && starGameTimeLeft > 0) {
                playTickSound();
            }
            
            updateGameScore();
            if (starGameTimeLeft <= 0) {
                toggleStarGame(); // End game when time runs out
            }
        }, 1000);
        
        // Start shooting star spawner
        scheduleNextShootingStar();
    } else {
        // Stop timer
        if (starGameTimerInterval) {
            clearInterval(starGameTimerInterval);
            starGameTimerInterval = null;
        }
        
        // Stop shooting star timer
        if (shootingStarTimer) {
            clearTimeout(shootingStarTimer);
            shootingStarTimer = null;
        }
        
        // Clear particles and shooting star
        particles = [];
        shootingStar = null;
        shootingStars = []; // Clear comet array too
        
        // Save current mode before resetting (for game over modal)
        const playedMode = gameMode;
        
        // Reset game mode and stars to normal
        gameMode = 'normal';
        initConstellation();
        
        btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="12,2 15,9 22,9 17,14 19,21 12,17 5,21 7,14 2,9 9,9" fill="rgba(198, 232, 232, 0.2)" stroke="#C6E8E8"/>
        </svg>`;
        btn.title = 'Star Hunt Game';
        
        // Show game over modal with the mode that was played
        showGameOverModal(playedMode);
    }
}

function showGameOverModal(playedMode) {
    const modal = document.getElementById('gameOverModal');
    const currentModeRecord = modeRecords[playedMode] || 0;
    const isNewRecord = starGameScore > currentModeRecord;
    
    // Update record if new high score
    if (isNewRecord) {
        modeRecords[playedMode] = starGameScore;
        // Create fresh object to ensure proper cookie serialization
        setCookie('starGameModeRecords', { ...modeRecords });
        playNewRecordSound();
    } else {
        playGameOverSound();
    }
    
    // Get the final record to display (either the new score or the old record)
    const displayRecord = isNewRecord ? starGameScore : currentModeRecord;
    
    // Update modal content
    document.getElementById('gameOverScore').textContent = starGameScore;
    document.getElementById('statRegular').textContent = starGameStats.regular;
    document.getElementById('statTwinkle').textContent = starGameStats.twinkle;
    document.getElementById('statBonus').textContent = starGameStats.bonus;
    document.getElementById('statComet').textContent = starGameStats.comet;
    
    const recordEl = document.getElementById('gameOverRecord');
    if (isNewRecord) {
        recordEl.textContent = `🏆 NEW ${playedMode.toUpperCase()} RECORD! 🏆`;
        recordEl.style.color = 'var(--gold)';
    } else {
        // Show the current mode's name and best score
        const modeName = playedMode.charAt(0).toUpperCase() + playedMode.slice(1);
        const modeNameFormatted = modeName === 'Starclear' ? 'Star Clear' : modeName;
        recordEl.textContent = `${modeNameFormatted} Best: ${displayRecord}`;
        recordEl.style.color = 'var(--muted)';
    }
    
    modal.classList.add('visible');
}

function updateGameScore(animateScore = false) {
    const scoreEl = document.getElementById('gameScore');
    const labelEl = document.querySelector('.star-game-score .label');
    
    // Only animate score if explicitly requested (on star collection)
    if (animateScore) {
        scoreEl.classList.add('pop');
        setTimeout(() => scoreEl.classList.remove('pop'), 150);
    }
    
    scoreEl.textContent = starGameScore;
    
    // Show current mode's record
    const currentModeRecord = modeRecords[gameMode] || 0;
    document.getElementById('gameRecord').textContent = `Record: ${currentModeRecord}`;
    
    // Update label to show time remaining
    if (starGameActive && labelEl) {
        labelEl.textContent = `TIME: ${starGameTimeLeft}s`;
        
        // Make timer red in last 10 seconds (tick sound handled in timer interval)
        if (starGameTimeLeft <= 10) {
            labelEl.classList.add('danger');
        } else {
            labelEl.classList.remove('danger');
        }
    } else if (labelEl) {
        labelEl.textContent = 'STARS COLLECTED';
        labelEl.classList.remove('danger');
    }
}

// ── SOUND GENERATION ──────────────────────────────────────────────────
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

function playPopSound(type = 'regular') {
    if (!starGameActive) return;
    
    const now = audioContext.currentTime;
    
    if (type === 'comet') {
        // Epic explosion sound for comets - deep and powerful
        // Bass explosion layer
        const bass = audioContext.createOscillator();
        const bassGain = audioContext.createGain();
        bass.connect(bassGain);
        bassGain.connect(audioContext.destination);
        
        bass.type = 'sine';
        bass.frequency.setValueAtTime(150, now);
        bass.frequency.exponentialRampToValueAtTime(40, now + 0.3);
        
        bassGain.gain.setValueAtTime(0, now);
        bassGain.gain.linearRampToValueAtTime(0.4, now + 0.02);
        bassGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        
        bass.start(now);
        bass.stop(now + 0.4);
        
        // Mid-range crackle
        const mid = audioContext.createOscillator();
        const midGain = audioContext.createGain();
        const midFilter = audioContext.createBiquadFilter();
        
        mid.connect(midFilter);
        midFilter.connect(midGain);
        midGain.connect(audioContext.destination);
        
        mid.type = 'sawtooth';
        mid.frequency.setValueAtTime(300, now);
        mid.frequency.exponentialRampToValueAtTime(100, now + 0.2);
        
        midFilter.type = 'lowpass';
        midFilter.frequency.setValueAtTime(800, now);
        midFilter.frequency.exponentialRampToValueAtTime(200, now + 0.2);
        
        midGain.gain.setValueAtTime(0, now);
        midGain.gain.linearRampToValueAtTime(0.25, now + 0.01);
        midGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
        
        mid.start(now);
        mid.stop(now + 0.25);
        
        // High impact "crash"
        const bufferSize = audioContext.sampleRate * 0.15;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / bufferSize * 8);
        }
        const noise = audioContext.createBufferSource();
        const noiseGain = audioContext.createGain();
        const noiseFilter = audioContext.createBiquadFilter();
        
        noise.buffer = buffer;
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(audioContext.destination);
        
        noiseFilter.type = 'bandpass';
        noiseFilter.frequency.setValueAtTime(400, now);
        noiseGain.gain.setValueAtTime(0.2, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        
        noise.start(now);
        
    } else if (type === 'bonus') {
        // Magical "power-up" sound for bonus stars - lower and warmer
        const osc1 = audioContext.createOscillator();
        const osc2 = audioContext.createOscillator();
        const gain1 = audioContext.createGain();
        const gain2 = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        osc1.connect(gain1);
        osc2.connect(gain2);
        gain1.connect(filter);
        gain2.connect(filter);
        filter.connect(audioContext.destination);
        
        // Two oscillators for a richer sound
        osc1.type = 'sine';
        osc2.type = 'sine';
        
        // Lower frequency range - more pleasant
        osc1.frequency.setValueAtTime(400, now);
        osc1.frequency.exponentialRampToValueAtTime(600, now + 0.15);
        
        osc2.frequency.setValueAtTime(500, now); // Fifth above
        osc2.frequency.exponentialRampToValueAtTime(750, now + 0.15);
        
        // Gentle lowpass filter for smoothness
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1500, now);
        filter.frequency.exponentialRampToValueAtTime(2500, now + 0.1);
        filter.Q.setValueAtTime(2, now);
        
        // Volume envelopes
        gain1.gain.setValueAtTime(0, now);
        gain1.gain.linearRampToValueAtTime(0.15, now + 0.02);
        gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
        
        gain2.gain.setValueAtTime(0, now);
        gain2.gain.linearRampToValueAtTime(0.1, now + 0.02);
        gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
        
        osc1.start(now);
        osc1.stop(now + 0.25);
        osc2.start(now);
        osc2.stop(now + 0.25);
        
    } else if (type === 'twinkle') {
        // Warmer pop with slight pitch wobble for twinkle stars
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = 'triangle'; // Warmer than sine
        oscillator.frequency.setValueAtTime(700, now);
        oscillator.frequency.exponentialRampToValueAtTime(500, now + 0.08);
        
        // Bandpass for character
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(800, now);
        filter.Q.setValueAtTime(3, now);
        
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.18, now + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
        
        oscillator.start(now);
        oscillator.stop(now + 0.12);
        
    } else {
        // Snappy bass pop for regular stars
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(300, now);
        oscillator.frequency.exponentialRampToValueAtTime(80, now + 0.04);
        
        // Punchy envelope
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.2, now + 0.005);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
        
        oscillator.start(now);
        oscillator.stop(now + 0.06);
    }
}

function playGameOverSound() {
    const now = audioContext.currentTime;
    
    // Sad descending arpeggio
    const notes = [600, 550, 500, 400, 350];
    notes.forEach((freq, i) => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(freq, now);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000 - (i * 100), now);
        
        const startTime = now + (i * 0.12);
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(0.15, startTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);
        
        oscillator.start(startTime);
        oscillator.stop(startTime + 0.25);
    });
    
    // Add low "thud" at the end
    const bass = audioContext.createOscillator();
    const bassGain = audioContext.createGain();
    bass.connect(bassGain);
    bassGain.connect(audioContext.destination);
    
    bass.type = 'sine';
    bass.frequency.setValueAtTime(100, now + 0.5);
    bass.frequency.exponentialRampToValueAtTime(40, now + 0.7);
    
    bassGain.gain.setValueAtTime(0, now + 0.5);
    bassGain.gain.linearRampToValueAtTime(0.3, now + 0.52);
    bassGain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
    
    bass.start(now + 0.5);
    bass.stop(now + 0.8);
}

function playNewRecordSound() {
    const now = audioContext.currentTime;
    
    // Epic victory fanfare with chord progressions
    const melody = [
        { freq: 523, time: 0 },      // C
        { freq: 659, time: 0.15 },   // E
        { freq: 784, time: 0.3 },    // G
        { freq: 1047, time: 0.45 }   // C (high)
    ];
    
    melody.forEach((note, i) => {
        // Main melody
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        
        osc.type = 'square';
        osc.frequency.setValueAtTime(note.freq, now + note.time);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(2000, now + note.time);
        filter.Q.setValueAtTime(1, now + note.time);
        
        gain.gain.setValueAtTime(0, now + note.time);
        gain.gain.linearRampToValueAtTime(0.12, now + note.time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, now + note.time + 0.2);
        
        osc.start(now + note.time);
        osc.stop(now + note.time + 0.2);
        
        // Harmony (third above)
        const harm = audioContext.createOscillator();
        const harmGain = audioContext.createGain();
        
        harm.connect(harmGain);
        harmGain.connect(audioContext.destination);
        
        harm.type = 'sine';
        harm.frequency.setValueAtTime(note.freq * 1.25, now + note.time);
        
        harmGain.gain.setValueAtTime(0, now + note.time);
        harmGain.gain.linearRampToValueAtTime(0.06, now + note.time + 0.01);
        harmGain.gain.exponentialRampToValueAtTime(0.001, now + note.time + 0.2);
        
        harm.start(now + note.time);
        harm.stop(now + note.time + 0.2);
    });
    
    // Add shimmer at the end
    for (let i = 0; i < 5; i++) {
        const shimmer = audioContext.createOscillator();
        const shimmerGain = audioContext.createGain();
        
        shimmer.connect(shimmerGain);
        shimmerGain.connect(audioContext.destination);
        
        shimmer.type = 'sine';
        shimmer.frequency.setValueAtTime(2000 + (i * 400), now + 0.5 + (i * 0.05));
        
        shimmerGain.gain.setValueAtTime(0.05, now + 0.5 + (i * 0.05));
        shimmerGain.gain.exponentialRampToValueAtTime(0.001, now + 0.7 + (i * 0.05));
        
        shimmer.start(now + 0.5 + (i * 0.05));
        shimmer.stop(now + 0.7 + (i * 0.05));
    }
}

function playUnlockSound() {
    const now = audioContext.currentTime;
    
    // Three ascending arpeggios - C major, D major, E major
    const arpeggios = [
        [261.63, 329.63, 392.00, 523.25], // C major arpeggio (C-E-G-C)
        [293.66, 369.99, 440.00, 587.33], // D major arpeggio (D-F#-A-D)
        [329.63, 415.30, 493.88, 659.25]  // E major arpeggio (E-G#-B-E)
    ];
    
    let timeOffset = 0;
    
    arpeggios.forEach((arpeggio, arpeggioIndex) => {
        arpeggio.forEach((freq, noteIndex) => {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, now + timeOffset);
            
            // Bright filter
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(3000, now + timeOffset);
            filter.Q.setValueAtTime(2, now + timeOffset);
            
            // Quick attack, sustain
            gain.gain.setValueAtTime(0, now + timeOffset);
            gain.gain.linearRampToValueAtTime(0.15, now + timeOffset + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, now + timeOffset + 0.25);
            
            osc.start(now + timeOffset);
            osc.stop(now + timeOffset + 0.25);
            
            timeOffset += 0.1; // 100ms between notes
        });
        
        timeOffset += 0.1; // Extra gap between arpeggios
    });
}

function playTickSound() {
    if (!starGameActive) return;
    
    // Prevent tick from playing more than once per second
    const now = Date.now();
    if (now - lastTickTime < 900) return; // 900ms cooldown
    lastTickTime = now;
    
    const audioNow = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, audioNow);
    
    gain.gain.setValueAtTime(0.1, audioNow);
    gain.gain.exponentialRampToValueAtTime(0.001, audioNow + 0.05);
    
    osc.start(audioNow);
    osc.stop(audioNow + 0.05);
}

// ── PARTICLE EFFECTS ──────────────────────────────────────────────────
function createParticles(x, y, color, count = 8) {
    if (!starGameActive && !saveStarsActive) return;
    
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = 2 + Math.random() * 3;
        particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: 0.02 + Math.random() * 0.02,
            size: 2 + Math.random() * 2,
            color: color
        });
    }
}

function updateAndDrawParticles() {
    if (!starGameActive || particles.length === 0) return;
    
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        
        // Update
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1; // Gravity
        p.life -= p.decay;
        
        // Remove dead particles
        if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
        }
        
        // Draw
        const alpha = p.life;
        ctx.fillStyle = `rgba(${p.color}, ${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Glow
        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
        gradient.addColorStop(0, `rgba(${p.color}, ${alpha * 0.5})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(p.x - p.size * 2, p.y - p.size * 2, p.size * 4, p.size * 4);
    }
}

// ── SHOOTING STAR ─────────────────────────────────────────────────────
function spawnShootingStar() {
    // In comet mode, allow multiple comets
    if (gameMode === 'comet') {
        if (shootingStars.length >= 3) return; // Max 3 comets at once
    } else {
        if (shootingStar) return; // Only one in other modes
    }
    
    if (!starGameActive) return;
    
    // Detect mobile
    const isMobile = window.innerWidth < 768;
    
    // Random starting position
    let x, y, vx, vy;
    
    if (isMobile) {
        // On mobile: spawn from left/right edges, always go through middle, faster
        const fromLeft = Math.random() < 0.5;
        const verticalPos = h * 0.3 + Math.random() * h * 0.4; // 30-70% of screen height
        
        // Speed multiplier based on mode
        let speedMult = 1.0;
        if (gameMode === 'comet') speedMult = 1.4; // 40% faster in comet rush
        else if (gameMode === 'normal') speedMult = 1.2; // 20% faster in normal
        
        if (fromLeft) {
            x = -20;
            y = verticalPos;
            vx = (7 + Math.random() * 5) * speedMult; // Increased range: 7-12
            vy = (Math.random() - 0.5) * 3 * speedMult;
        } else {
            x = w + 20;
            y = verticalPos;
            vx = -(7 + Math.random() * 5) * speedMult;
            vy = (Math.random() - 0.5) * 3 * speedMult;
        }
    } else {
        // Desktop: original behavior from any edge
        const side = Math.floor(Math.random() * 4);
        
        // Speed multiplier based on mode
        let speedMult = 1.0;
        if (gameMode === 'comet') speedMult = 1.4; // 40% faster in comet rush
        else if (gameMode === 'normal') speedMult = 1.2; // 20% faster in normal
        
        if (side === 0) { // Top
            x = Math.random() * w;
            y = -20;
            vx = (Math.random() - 0.5) * 7 * speedMult; // Increased range
            vy = (4.8 + Math.random() * 4) * speedMult; // 4.8-8.8
        } else if (side === 1) { // Right
            x = w + 20;
            y = Math.random() * h;
            vx = -(4.8 + Math.random() * 4) * speedMult;
            vy = (Math.random() - 0.5) * 7 * speedMult;
        } else if (side === 2) { // Bottom
            x = Math.random() * w;
            y = h + 20;
            vx = (Math.random() - 0.5) * 7 * speedMult;
            vy = -(4.8 + Math.random() * 4) * speedMult;
        } else { // Left
            x = -20;
            y = Math.random() * h;
            vx = (4.8 + Math.random() * 4) * speedMult;
            vy = (Math.random() - 0.5) * 7 * speedMult;
        }
    }
    
    const newComet = {
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        trail: [],
        radius: 6,
        points: 15
    };
    
    // In comet mode, add to array; otherwise use single comet
    if (gameMode === 'comet') {
        shootingStars.push(newComet);
    } else {
        shootingStar = newComet;
    }
    
    // Schedule next shooting star
    scheduleNextShootingStar();
}

function scheduleNextShootingStar() {
    if (!starGameActive) return;
    
    let delay;
    if (gameMode === 'comet') {
        delay = (1 + Math.random() * 2) * 1000; // 1-3 seconds in comet mode!
    } else if (gameMode === 'twinkle' || gameMode === 'starclear') {
        return; // No comets in these modes
    } else {
        delay = (5 + Math.random() * 10) * 1000; // 5-15 seconds normally
    }
    
    shootingStarTimer = setTimeout(spawnShootingStar, delay);
}

function updateAndDrawShootingStar() {
    // Handle single comet (normal modes)
    if (shootingStar) {
        updateSingleComet(shootingStar);
        
        // Remove if offscreen
        if (shootingStar.x < -50 || shootingStar.x > w + 50 ||
            shootingStar.y < -50 || shootingStar.y > h + 50) {
            shootingStar = null;
        }
    }
    
    // Handle multiple comets (comet rush mode)
    for (let i = shootingStars.length - 1; i >= 0; i--) {
        const comet = shootingStars[i];
        updateSingleComet(comet);
        
        // Remove if offscreen
        if (comet.x < -50 || comet.x > w + 50 ||
            comet.y < -50 || comet.y > h + 50) {
            shootingStars.splice(i, 1);
        }
    }
}

function updateSingleComet(star) {
    // Update position
    star.x += star.vx;
    star.y += star.vy;
    
    // Add to trail
    star.trail.push({ x: star.x, y: star.y });
    if (star.trail.length > 15) {
        star.trail.shift();
    }
    
    // Draw trail
    for (let i = 0; i < star.trail.length; i++) {
        const t = star.trail[i];
        const alpha = (i / star.trail.length) * 0.8;
        const size = (i / star.trail.length) * star.radius;
        
        // Red gradient trail
        const gradient = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, size * 3);
        gradient.addColorStop(0, `rgba(255, 100, 100, ${alpha})`);
        gradient.addColorStop(0.5, `rgba(255, 150, 100, ${alpha * 0.5})`);
        gradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(t.x - size * 3, t.y - size * 3, size * 6, size * 6);
    }
    
    // Draw shooting star core
    const coreGradient = ctx.createRadialGradient(
        star.x, star.y, 0,
        star.x, star.y, star.radius * 3
    );
    coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
    coreGradient.addColorStop(0.3, 'rgba(255, 100, 100, 0.8)');
    coreGradient.addColorStop(1, 'rgba(255, 100, 100, 0)');
    ctx.fillStyle = coreGradient;
    ctx.fillRect(
        star.x - star.radius * 3,
        star.y - star.radius * 3,
        star.radius * 6,
        star.radius * 6
    );
    
    // Draw star core
    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
    ctx.fill();
}

// ── ANTI-CHEAT ────────────────────────────────────────────────────────
function showCheatWarning() {
    const modal = document.getElementById('cheatWarningModal');
    modal.classList.add('visible');
    
    // Pause game but don't end it
    if (starGameTimerInterval) {
        clearInterval(starGameTimerInterval);
        starGameTimerInterval = null;
    }
}

function checkStarClick(x, y) {
    if (!starGameActive) return;
    
    // Anti-cheat: Check click rate
    const now = Date.now();
    clickTimes.push(now);
    
    // Keep only clicks from the last second
    clickTimes = clickTimes.filter(time => now - time < 1000);
    
    // If too many clicks per second, show warning
    if (clickTimes.length > MAX_CPS) {
        showCheatWarning();
        return false;
    }
    
    const clickRadius = 25; // Increased from 20 for easier comet clicking
    
    // Check single shooting star first (normal modes)
    if (shootingStar) {
        const dx = shootingStar.x - x;
        const dy = shootingStar.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < clickRadius + 5) { // Extra 5px for comets
            starGameScore += shootingStar.points;
            starGameStats.comet++;
            createParticles(shootingStar.x, shootingStar.y, '255, 100, 100', 30);
            playPopSound('comet');
            updateGameScore(true);
            
            // Check for unlocks during gameplay (only in normal mode)
            if (gameMode === 'normal') {
                checkForUnlocksDuringGame();
            }
            
            shootingStar = null;
            return true;
        }
    }
    
    // Check multiple shooting stars (comet rush mode)
    for (let i = shootingStars.length - 1; i >= 0; i--) {
        const star = shootingStars[i];
        const dx = star.x - x;
        const dy = star.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < clickRadius + 5) {
            starGameScore += star.points;
            starGameStats.comet++;
            createParticles(star.x, star.y, '255, 100, 100', 30);
            playPopSound('comet');
            updateGameScore(true);
            
            // Check for unlocks during gameplay (only in normal mode)
            if (gameMode === 'normal') {
                checkForUnlocksDuringGame();
            }
            
            shootingStars.splice(i, 1);
            return true;
        }
    }
    
    // Check twinkling stars
    for (let i = twinklingStars.length - 1; i >= 0; i--) {
        const star = twinklingStars[i];
        const dx = star.x - x;
        const dy = star.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < clickRadius) {
            starGameScore += star.points;
            
            // Track star type and create effects
            if (star.isFast) {
                starGameStats.bonus++;
                createParticles(star.x, star.y, '142, 216, 216', 12); // Bright cyan, more particles
                playPopSound('bonus');
                
                // Check for unlocks during gameplay (only in normal mode)
                if (gameMode === 'normal') {
                    checkForUnlocksDuringGame();
                }
            } else {
                starGameStats.twinkle++;
                createParticles(star.x, star.y, '198, 232, 232', 8); // Normal cyan
                playPopSound('twinkle');
            }
            
            updateGameScore(true); // Animate score
            twinklingStars.splice(i, 1);
            
            // Remove from fastTwinklers if present
            const fastIdx = fastTwinklers.indexOf(star);
            if (fastIdx >= 0) fastTwinklers.splice(fastIdx, 1);
            
            // Spawn replacement
            spawnTwinklingStar();
            return true;
        }
    }
    
    // Check constellation stars (skip in twinkle mode - only twinkle/bonus stars there)
    if (gameMode === 'twinkle') return false;
    
    // Check constellation stars (1 point, respawn immediately except in star clear mode)
    for (const star of stars) {
        const dx = star.x - x;
        const dy = star.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < clickRadius) {
            starGameScore += 1;
            starGameStats.regular++;
            createParticles(star.x, star.y, '255, 255, 255', 6); // White particles
            playPopSound('regular');
            updateGameScore(true); // Animate score
            
            // Check for unlocks during gameplay (only in normal mode)
            if (gameMode === 'normal') {
                checkForUnlocksDuringGame();
            }
            
            // In star clear mode, remove the star permanently
            if (gameMode === 'starclear') {
                const index = stars.indexOf(star);
                if (index > -1) stars.splice(index, 1);
            } else {
                // In other modes, respawn star at new position
                star.x = Math.random() * w;
                star.y = Math.random() * h;
            }
            return true;
        }
    }
    
    return false;
}

// ── CONFIG ────────────────────────────────────────────────────────────
const BASE_URL = 'https://raw.githubusercontent.com/TheDogVT/Achievements/main';

// ── COOKIE HELPERS ────────────────────────────────────────────────────
function setCookie(name, value, days = 365) {
    const date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    document.cookie = `${name}=${JSON.stringify(value)};expires=${date.toUTCString()};path=/`;
}

function getCookie(name) {
    const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
    if (match) {
        try {
            return JSON.parse(match[2]);
        } catch {
            return null;
        }
    }
    return null;
}

// ── DATA ──────────────────────────────────────────────────────────────
let achData      = {};
let foundersData = {};
let usernameMap  = {};
let allUserData  = {};
let rarityData   = {};
let currentUserId   = null;
let currentCategory = 'all';
let currentFilter   = 'all';
let currentSort     = 'recent';

// ── LOADING ───────────────────────────────────────────────────────────
function setLoadProgress(pct, msg) {
    document.getElementById('loadingBarFill').style.width = pct + '%';
    document.getElementById('loadingStatus').textContent  = msg;
}

async function loadAllData() {
    setLoadProgress(5, 'Loading achievements…');
    const [achRes, mapRes] = await Promise.all([
        fetch(`${BASE_URL}/achievements.json`),
        fetch(`${BASE_URL}/username_map.json`),
    ]);
    achData     = await achRes.json();
    usernameMap = mapRes.ok ? await mapRes.json() : {};

    setLoadProgress(20, 'Loading user data…');

    const uniqueIds  = [...new Set(Object.values(usernameMap))];
    const BATCH_SIZE = 50;
    let loaded = 0;

    for (let i = 0; i < uniqueIds.length; i += BATCH_SIZE) {
        const batch = uniqueIds.slice(i, i + BATCH_SIZE);
        await Promise.all(batch.map(async (id) => {
            try {
                const res = await fetch(`${BASE_URL}/users/${id}.json`);
                if (res.ok) allUserData[id] = await res.json();
            } catch (_) { }
            loaded++;
        }));
        const pct = 20 + Math.round((loaded / uniqueIds.length) * 70);
        setLoadProgress(pct, `Loading users… ${loaded} / ${uniqueIds.length}`);
    }

    setLoadProgress(92, 'Building founder data…');
    for (const [userId, userData] of Object.entries(allUserData)) {
        const founded = userData?.achievements?.founded || {};
        for (const [achId, timestamp] of Object.entries(founded)) {
            const existing = foundersData[achId];
            if (!existing || timestamp < existing.founded_at) {
                foundersData[achId] = {
                    founder_id:   userId,
                    founder_name: userData.username || userId,
                    founded_at:   timestamp,
                };
            }
        }
    }

    setLoadProgress(96, 'Computing rarity…');
    const totalUsers = Object.keys(allUserData).length;
    const achCounts  = {};

    for (const userData of Object.values(allUserData)) {
        const earned  = Object.keys(userData?.achievements?.earned  || {});
        const founded = Object.keys(userData?.achievements?.founded || {});
        const all = new Set([...earned, ...founded]);
        for (const achId of all) {
            achCounts[achId] = (achCounts[achId] || 0) + 1;
        }
    }

    for (const achId of Object.keys(achCounts)) {
        const count = achCounts[achId];
        rarityData[achId] = {
            count: count,
            percentage: totalUsers > 0 ? ((count / totalUsers) * 100) : 0,
            total: totalUsers
        };
    }

    setLoadProgress(100, 'Done!');
    await new Promise(r => setTimeout(r, 300));

    const screen = document.getElementById('loadingScreen');
    screen.classList.add('fade-out');
    setTimeout(() => screen.remove(), 400);
    document.getElementById('appContent').style.display = 'block';
}

// ── BUILD LEADERBOARD ─────────────────────────────────────────────────
function buildLeaderboard() {
    const grid = document.getElementById('leaderboardGrid');
    
    // Define categories and their achievement prefixes
    const categories = [
        { name: 'Bits', prefix: 'cheer', icon: '⚡' },
        { name: 'Donations', prefix: 'donation', icon: '💸' },
        { name: 'Gifted Subs', prefix: 'gifted', icon: '🎁' }
    ];
    
    grid.innerHTML = '';
    
    for (const category of categories) {
        const column = document.createElement('div');
        column.className = 'leaderboard-column';
        
        const title = document.createElement('div');
        title.className = 'leaderboard-category';
        title.textContent = `${category.icon} ${category.name}`;
        column.appendChild(title);
        
        // Find each user's highest achievement amount in this category
        const userMaxAchs = [];
        for (const [userId, userData] of Object.entries(allUserData)) {
            let maxAmount = 0;
            let maxAch = null;
            let maxAchId = null;
            let maxAchTs = null;
            
            for (const cat of Object.keys(achData)) {
                for (const [id, ach] of Object.entries(achData[cat])) {
                    if (id.startsWith(category.prefix) && ach.amount) {
                        const earned = userData.achievements?.earned?.[id];
                        const founded = userData.achievements?.founded?.[id];
                        if (earned || founded) {
                            if (ach.amount > maxAmount) {
                                maxAmount = ach.amount;
                                maxAch = ach;
                                maxAchId = id;
                                maxAchTs = earned || founded;
                            }
                        }
                    }
                }
            }
            
            if (maxAch) {
                userMaxAchs.push({
                    userId,
                    username: userData.username || userId,
                    achId: maxAchId,
                    achName: maxAch.name,
                    achDesc: maxAch.desc,
                    amount: maxAmount,
                    timestamp: maxAchTs,
                    rarity: rarityData[maxAchId]?.percentage || 100
                });
            }
        }
        
        // Sort by amount (desc), then by timestamp (most recent first)
        userMaxAchs.sort((a, b) => {
            if (b.amount !== a.amount) return b.amount - a.amount;
            return new Date(b.timestamp) - new Date(a.timestamp);
        });
        
        // Take top 3
        const top3 = userMaxAchs.slice(0, 3);
        
        // Create leaderboard items
        for (const entry of top3) {
            const item = document.createElement('div');
            item.className = 'leaderboard-item';
            
            const userDiv = document.createElement('div');
            userDiv.className = 'leaderboard-user';
            userDiv.style.cursor = 'pointer';
            userDiv.addEventListener('click', () => {
                loadUser(entry.userId);
                document.getElementById('userIdInput').value = entry.username;
            });
            
            const avatar = document.createElement('div');
            avatar.className = 'leaderboard-avatar';
            avatar.dataset.username = entry.username;
            avatar.textContent = entry.username[0].toUpperCase();
            avatar.style.backgroundSize = 'cover';
            avatar.style.backgroundPosition = 'center';
            
            const username = document.createElement('div');
            username.className = 'leaderboard-username';
            username.textContent = entry.username;
            
            userDiv.appendChild(avatar);
            userDiv.appendChild(username);
            
            const achName = document.createElement('div');
            achName.className = 'leaderboard-ach-name';
            achName.textContent = entry.achName;
            
            const achDesc = document.createElement('div');
            achDesc.className = 'leaderboard-ach-desc';
            achDesc.textContent = entry.achDesc;
            
            const rarity = document.createElement('div');
            rarity.className = 'leaderboard-rarity';
            rarity.textContent = `Top ${entry.rarity.toFixed(1)}%`;
            
            item.appendChild(userDiv);
            item.appendChild(achName);
            item.appendChild(achDesc);
            item.appendChild(rarity);
            column.appendChild(item);
        }
        
        grid.appendChild(column);
    }
    
    // Fetch Twitch pfps for leaderboard after building
    setTimeout(() => fetchTwitchPfps(), 100);
}

// ── CATEGORY ICONS ────────────────────────────────────────────────────
const CAT_ICONS = {
    chat:     '💬',
    gamble:   '🎲',
    cheer:    '⚡',
    donation: '💸',
    gifted:   '🎁',
    redeem:   '🔑',
    specific: '⭐',
};

// ── TOAST ─────────────────────────────────────────────────────────────
let toastTimer;
function showToast(msg, isError = false, variant = 'default') {
    const el = document.getElementById('toast');
    el.textContent = msg;
    let className = 'show';
    if (isError) className += ' error';
    if (variant === 'gold') className += ' gold';
    el.className = className;
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => { el.className = ''; }, 4000); // Longer for unlock messages
}

// ── BUILD TABS ────────────────────────────────────────────────────────
function buildTabs(cats) {
    const header = document.getElementById('tabsHeader');
    header.innerHTML = '';
    const allBtn = makeTabBtn('all', '🏆', 'All');
    header.appendChild(allBtn);
    for (const cat of cats) {
        header.appendChild(makeTabBtn(cat, CAT_ICONS[cat] || '🔹', capitalize(cat)));
    }
    updateTabBadges();
}

function makeTabBtn(cat, icon, label) {
    const btn = document.createElement('button');
    btn.className = 'tab-btn' + (cat === currentCategory ? ' active' : '');
    btn.dataset.cat = cat;
    btn.innerHTML = `${icon} ${label} <span class="badge" id="badge-${cat}">0</span>`;
    btn.addEventListener('click', () => {
        currentCategory = cat;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        renderAchievements();
    });
    return btn;
}

function updateTabBadges() {
    const userData = currentUserId ? allUserData[currentUserId] : null;
    const allCats = ['all', ...Object.keys(achData)];

    for (const cat of allCats) {
        const badge = document.getElementById(`badge-${cat}`);
        if (!badge) continue;

        if (!userData) {
            if (cat === 'all') {
                badge.textContent = Object.values(achData).reduce((s, v) => s + Object.keys(v).length, 0);
            } else {
                badge.textContent = Object.keys(achData[cat] || {}).length;
            }
        } else {
            const earned  = userData.achievements?.earned  || {};
            const founded = userData.achievements?.founded || {};
            const userAchs = new Set([...Object.keys(earned), ...Object.keys(founded)]);

            if (cat === 'all') {
                badge.textContent = userAchs.size;
            } else {
                const catAchs = Object.keys(achData[cat] || {});
                const count = catAchs.filter(id => userAchs.has(id)).length;
                badge.textContent = count;
            }
        }
    }
}

// ── BUILD SORT DROPDOWN ───────────────────────────────────────────────
function buildSortOptions() {
    const select = document.getElementById('sortSelect');
    select.innerHTML = '';

    if (!currentUserId) {
        select.innerHTML = `
            <option value="name">Name (A-Z)</option>
            <option value="rarity">Rarity (Rarest first)</option>
            <option value="founded">Most recently founded</option>
        `;
        currentSort = 'name';
    } else {
        select.innerHTML = `
            <option value="recent">Most recently unlocked</option>
            <option value="rarity">Rarity (Rarest first)</option>
            <option value="name">Name (A-Z)</option>
        `;
        currentSort = 'recent';
    }
    select.value = currentSort;
}

// ── AUTOCOMPLETE ──────────────────────────────────────────────────────
let autocompleteIndex = -1;
let autocompleteMatches = [];

function updateAutocomplete(query) {
    const dropdown = document.getElementById('autocomplete');
    
    if (!query || query.length < 2) {
        dropdown.classList.remove('visible');
        autocompleteMatches = [];
        return;
    }

    const lowerQuery = query.toLowerCase();
    const matches = Object.entries(usernameMap)
        .filter(([username, id]) => 
            username.toLowerCase().includes(lowerQuery) || 
            id.includes(query)
        )
        .sort((a, b) => a[0].length - b[0].length) // Sort by shortest name first
        .slice(0, 10);

    autocompleteMatches = matches;
    autocompleteIndex = -1;

    if (matches.length === 0) {
        dropdown.innerHTML = '<div class="autocomplete-empty">No users found</div>';
        dropdown.classList.add('visible');
        return;
    }

    dropdown.innerHTML = matches.map(([username, id], idx) => {
        const highlight = username.toLowerCase().indexOf(lowerQuery);
        let displayName = username;
        
        if (highlight >= 0) {
            const before = username.slice(0, highlight);
            const match = username.slice(highlight, highlight + query.length);
            const after = username.slice(highlight + query.length);
            displayName = `${before}<strong>${match}</strong>${after}`;
        }
        
        return `
            <div class="autocomplete-item" data-index="${idx}">
                <span class="username">${displayName}</span>
                <span class="id">${id}</span>
            </div>
        `;
    }).join('');

    dropdown.classList.add('visible');
}

function selectAutocompleteItem(index) {
    if (index < 0 || index >= autocompleteMatches.length) return;
    const [username] = autocompleteMatches[index];
    document.getElementById('userIdInput').value = username;
    document.getElementById('autocomplete').classList.remove('visible');
    loadUser(username);
}

function highlightAutocompleteItem(index) {
    const items = document.querySelectorAll('.autocomplete-item');
    items.forEach((item, idx) => {
        item.classList.toggle('selected', idx === index);
    });
    
    if (index >= 0 && items[index]) {
        items[index].scrollIntoView({ block: 'nearest' });
    }
}

// ── RENDER ────────────────────────────────────────────────────────────
function renderAchievements() {
    const container = document.getElementById('achievementsContainer');
    const userData  = currentUserId ? allUserData[currentUserId] : null;
    container.innerHTML = '';

    const catsToShow = currentCategory === 'all'
        ? Object.keys(achData)
        : [currentCategory];

    let items = [];

    for (const cat of catsToShow) {
        for (const [id, ach] of Object.entries(achData[cat] || {})) {
            const earnedTs  = userData?.achievements?.earned?.[id];
            const foundedTs = userData?.achievements?.founded?.[id];
            const isEarned  = !!(earnedTs || foundedTs);
            const isFounder = !!foundedTs;
            const rarity    = rarityData[id] || { count: 0, percentage: 0, total: 0 };

            if (currentFilter === 'all'      && userData && !isEarned) continue;
            if (currentFilter === 'unlocked' && (!isEarned || isFounder)) continue;
            if (currentFilter === 'founder'  && !isFounder) continue;

            items.push({
                id, ach, cat, isEarned, isFounder,
                earnedTs: earnedTs || foundedTs,
                rarity,
            });
        }
    }

    // Sort
    if (currentSort === 'name') {
        items.sort((a, b) => a.ach.name.localeCompare(b.ach.name));
    } else if (currentSort === 'rarity') {
        items.sort((a, b) => a.rarity.percentage - b.rarity.percentage);
    } else if (currentSort === 'recent') {
        items.sort((a, b) => {
            if (!a.earnedTs) return 1;
            if (!b.earnedTs) return -1;
            return new Date(b.earnedTs) - new Date(a.earnedTs);
        });
    } else if (currentSort === 'founded') {
        items.sort((a, b) => {
            const aFounder = foundersData[a.id];
            const bFounder = foundersData[b.id];
            if (!aFounder) return 1;
            if (!bFounder) return -1;
            return new Date(bFounder.founded_at) - new Date(aFounder.founded_at);
        });
    }

    items.forEach((item, idx) => {
        const card = buildCard(item, userData);
        card.style.animationDelay = `${idx * 20}ms`;
        container.appendChild(card);
    });
    
    // Normalize card heights within each row after rendering
    setTimeout(() => normalizeCardHeights(), 100);

    if (items.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        const msg = userData
            ? 'No achievements match this filter.'
            : 'Search for a user to see their achievements.';
        empty.innerHTML = `<div class="icon">🎯</div><p>${msg}</p>`;
        container.appendChild(empty);
    }

    updateStatus(items.length);
    
    // Fetch Twitch pfps for recent users after rendering
    setTimeout(() => fetchTwitchPfps(), 100);
}

// ── NORMALIZE CARD HEIGHTS ────────────────────────────────────────────
function normalizeCardHeights() {
    const container = document.getElementById('achievementsContainer');
    const cards = Array.from(container.querySelectorAll('.achievement'));
    
    if (cards.length === 0) return;
    
    // Group cards by row based on their offsetTop
    const rows = new Map();
    cards.forEach(card => {
        const top = card.offsetTop;
        if (!rows.has(top)) rows.set(top, []);
        rows.get(top).push(card);
    });
    
    // Set min-height for each row to match the tallest card
    rows.forEach(rowCards => {
        const maxHeight = Math.max(...rowCards.map(c => c.offsetHeight));
        rowCards.forEach(c => {
            c.style.minHeight = maxHeight + 'px';
            c.dataset.rowHeight = maxHeight;
        });
    });
}

// ── FETCH TWITCH PFPS ─────────────────────────────────────────────────
function fetchTwitchPfps() {
    // Only fetch for leaderboard avatars, not recent users (too many API calls)
    document.querySelectorAll('.leaderboard-avatar[data-username]').forEach(avatar => {
        const username = avatar.dataset.username;
        if (username) {
            fetch(`https://decapi.me/twitch/avatar/${username}`)
                .then(res => res.text())
                .then(url => {
                    if (url && !url.includes('User not found') && !url.includes('error')) {
                        avatar.style.backgroundImage = `url(${url})`;
                        avatar.style.backgroundSize = 'cover';
                        avatar.style.backgroundPosition = 'center';
                        avatar.textContent = '';
                    }
                })
                .catch(() => {});
        }
    });
}

function buildCard(item, userData) {
    const { id, ach, cat, isEarned, isFounder, earnedTs, rarity } = item;

    const isRare = rarity.percentage > 0 && rarity.percentage <= 5;

    const div = document.createElement('div');
    let classList = 'achievement';
    if (isFounder) {
        classList += ' founded';
        if (isRare) classList += ' rare';
        else classList += ' common';
    } else if (isEarned) {
        classList += ' unlocked';
    }
    div.className = classList;

    const icon = CAT_ICONS[cat] || '🔹';

    let badgeHTML = '';
    if (isFounder) {
        const founderClass = isRare ? 'badge-founder rare' : 'badge-founder common';
        badgeHTML += `<span class="ach-badge ${founderClass}">FOUNDER</span>`;
    }
    if (isEarned && !isFounder) badgeHTML += `<span class="ach-badge badge-earned">EARNED</span>`;
    if (!isEarned) badgeHTML += `<span class="ach-badge badge-locked">LOCKED</span>`;
    
    // Rarity badge
    if (rarity.count > 0) {
        if (userData && isEarned) {
            // User context: show percentage with rare class if top 5%
            const pct = rarity.percentage.toFixed(1);
            const rarityClass = isRare ? 'badge-rarity rare' : 'badge-rarity';
            badgeHTML += `<span class="ach-badge ${rarityClass}">Top ${pct}%</span>`;
        } else if (!userData) {
            // No user context: show count
            badgeHTML += `<span class="ach-badge badge-rarity">${rarity.count}/${rarity.total}</span>`;
        }
    }

    let metaHTML = '';
    if (isEarned && earnedTs) {
        const d = new Date(earnedTs);
        const formatted = d.toLocaleString('en-US', {
            month: 'short', day: 'numeric', year: 'numeric',
            hour: 'numeric', minute: '2-digit', hour12: true
        });
        const dotClass = isFounder ? 'dot-bright' : 'dot-cyan';
        const label    = isFounder ? 'Founded' : 'Unlocked';
        metaHTML += `<div class="ach-meta-row"><span class="dot ${dotClass}"></span>${label}: ${formatted}</div>`;
    }

    if (foundersData[id]) {
        const founderUserId = foundersData[id].founder_id;
        const founderName   = foundersData[id].founder_name;
        if (!userData || currentUserId !== founderUserId) {
            metaHTML += `<div class="ach-meta-row"><span class="dot dot-cyan"></span>First: ${founderName}</div>`;
        }
    }

    // Build recent users list (last 5 to unlock this achievement)
    let recentHTML = '';
    const recentUsers = [];
    for (const [uid, udata] of Object.entries(allUserData)) {
        const earned = udata.achievements?.earned?.[id];
        const founded = udata.achievements?.founded?.[id];
        const ts = earned || founded;
        if (ts) {
            recentUsers.push({
                userId: uid,
                username: udata.username || uid,
                timestamp: ts
            });
        }
    }
    recentUsers.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    const last5 = recentUsers.slice(0, 5);
    
    if (last5.length > 0) {
        recentHTML = last5.map(u => {
            const d = new Date(u.timestamp);
            const formatted = d.toLocaleString('en-US', {
                month: 'short', day: 'numeric', year: 'numeric'
            });
            const initial = u.username[0].toUpperCase();
            return `
                <div class="recent-user-item" data-userid="${u.userId}" style="cursor: pointer;">
                    <div class="recent-user-avatar" data-username="${u.username}">${initial}</div>
                    <div class="recent-user-info">
                        <div class="recent-user-name">${u.username}</div>
                        <div class="recent-user-date">${formatted}</div>
                    </div>
                </div>
            `;
        }).join('');
    }

    div.innerHTML = `
        <div class="ach-header">
            <div class="ach-icon">${icon}</div>
            <div class="ach-title-wrap">
                <div class="ach-name">${ach.name}</div>
                <div class="ach-badges">${badgeHTML}</div>
            </div>
        </div>
        <p class="ach-desc">${ach.desc}</p>
        ${metaHTML ? `<div class="ach-meta">${metaHTML}</div>` : ''}
        <div class="ach-spacer"></div>
        ${recentHTML ? `
            <button class="ach-expand-btn">
                <span class="arrow">▼</span>
                <span>Recently Unlocked</span>
                <span class="arrow">▼</span>
            </button>
            <div class="ach-recent-users">
                <div class="ach-recent-title">Last 5 Users</div>
                ${recentHTML}
            </div>
        ` : ''}
    `;
    
    // Add click handler for expand button
    const expandBtn = div.querySelector('.ach-expand-btn');
    if (expandBtn) {
        expandBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            div.classList.toggle('expanded');
        });
    }

    return div;
}

// ── PROFILE BANNER ────────────────────────────────────────────────────
function showProfile(userId) {
    const userData = allUserData[userId];
    if (!userData) return;

    const earned  = Object.keys(userData.achievements?.earned  || {}).length;
    const founded = Object.keys(userData.achievements?.founded || {}).length;
    const total   = Object.values(achData).reduce((s, v) => s + Object.keys(v).length, 0);
    const pct     = total > 0 ? Math.round(((earned + founded) / total) * 100) : 0;

    const name = userData.username || userId;
    document.getElementById('profileName').textContent   = name;
    document.getElementById('profileStats').textContent  =
        `${earned + founded} / ${total} earned (${pct}%)${founded > 0 ? ` · ${founded} founded` : ''}`;
    document.getElementById('progressFill').style.width  = pct + '%';
    document.getElementById('profileBanner').classList.add('visible');
    
    // Update claim button state (with small delay to ensure DOM is ready)
    const claimBtn = document.getElementById('claimBtn');
    const savedUser = getCookie('myAchievementsUser');
    setTimeout(() => {
        if (savedUser && savedUser.userId === userId) {
            claimBtn.classList.add('claimed');
            claimBtn.textContent = 'Saved ✓';
        } else {
            claimBtn.classList.remove('claimed');
            claimBtn.textContent = 'This is me!';
        }
    }, 50);
    
    // Try to fetch Twitch profile picture
    const avatarEl = document.getElementById('avatarEl');
    avatarEl.style.backgroundImage = 'none';
    avatarEl.textContent = name[0].toUpperCase();
    
    if (userData.username) {
        fetch(`https://decapi.me/twitch/avatar/${userData.username}`)
            .then(res => res.text())
            .then(url => {
                if (url && !url.includes('User not found') && !url.includes('error')) {
                    avatarEl.style.backgroundImage = `url(${url})`;
                    avatarEl.style.backgroundSize = 'cover';
                    avatarEl.style.backgroundPosition = 'center';
                    avatarEl.textContent = '';
                }
            })
            .catch(() => { /* keep default letter */ });
    }
}

function hideProfile() {
    document.getElementById('profileBanner').classList.remove('visible');
}

// ── STATUS BAR ────────────────────────────────────────────────────────
function updateStatus(count) {
    const bar = document.getElementById('statusBar');
    bar.textContent = `SHOWING ${count} DISCOVERED ACHIEVEMENT${count !== 1 ? 'S' : ''}`;
}

// ── LOAD USER ────────────────────────────────────────────────────────
function loadUser(usernameOrId) {
    if (!usernameOrId) return;
    let userId = usernameOrId.trim();

    if (isNaN(Number(userId))) {
        const resolved = usernameMap[userId.toLowerCase()];
        if (!resolved) { showToast('Username not found', true); return; }
        userId = resolved;
    }

    if (!allUserData[userId]) {
        showToast('No data found for that user', true);
        return;
    }

    currentUserId = userId;
    currentFilter = 'all';
    updateFilterChips();
    buildSortOptions();
    document.getElementById('filterRow').classList.add('visible');
    showProfile(userId);
    updateTabBadges();
    renderAchievements();
    
    // Scroll to top smoothly
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// ── FILTER CHIPS ──────────────────────────────────────────────────────
function updateFilterChips() {
    document.querySelectorAll('.filter-chip').forEach(c => {
        c.classList.toggle('active', c.dataset.filter === currentFilter);
    });
}

// ── INIT ──────────────────────────────────────────────────────────────
async function initPage() {
    buildTabs(Object.keys(achData));
    buildSortOptions();
    buildLeaderboard();
    
    // Start leaderboard auto-collapse timer
    startLeaderboardTimer();

    const userParam = new URLSearchParams(window.location.search).get('user');
    const savedUser = getCookie('myAchievementsUser');
    
    if (userParam) {
        loadUser(userParam);
    } else if (savedUser && savedUser.userId) {
        // Auto-load saved user
        loadUser(savedUser.userId);
        checkNewAchievements(savedUser);
    } else {
        currentFilter = 'all';
        updateFilterChips();
        renderAchievements();
    }
}

// ── LEADERBOARD AUTO-COLLAPSE TIMER ───────────────────────────────────
let leaderboardTimer = null;
function startLeaderboardTimer() {
    const leaderboard = document.getElementById('leaderboard');
    const timer = document.getElementById('leaderboardTimer');
    const timerFill = document.getElementById('leaderboardTimerFill');
    const timerLabel = document.getElementById('leaderboardTimerLabel');
    
    // Reset animation
    leaderboard.classList.remove('auto-collapsing');
    timer.style.display = 'block';
    timerLabel.style.display = 'block';
    
    // Force reflow to restart animation
    void timerFill.offsetWidth;
    
    // Start animation
    leaderboard.classList.add('auto-collapsing');
    
    leaderboardTimer = setTimeout(() => {
        leaderboard.classList.add('collapsed');
        timer.style.display = 'none';
        timerLabel.style.display = 'none';
        leaderboard.classList.remove('auto-collapsing');
    }, 5000);
}

function cancelLeaderboardTimer() {
    if (leaderboardTimer) {
        clearTimeout(leaderboardTimer);
        leaderboardTimer = null;
    }
    const leaderboard = document.getElementById('leaderboard');
    const timer = document.getElementById('leaderboardTimer');
    const timerLabel = document.getElementById('leaderboardTimerLabel');
    leaderboard.classList.remove('auto-collapsing');
    timer.style.display = 'none';
    timerLabel.style.display = 'none';
}

// ── CHECK NEW ACHIEVEMENTS ────────────────────────────────────────────
function checkNewAchievements(savedUser) {
    const userData = allUserData[savedUser.userId];
    if (!userData) return;
    
    const lastCheck = savedUser.lastAchievementDate ? new Date(savedUser.lastAchievementDate) : null;
    
    // Check for new founded achievements
    const founded = userData.achievements?.founded || {};
    const newFounded = [];
    for (const [achId, timestamp] of Object.entries(founded)) {
        const achDate = new Date(timestamp);
        if (!lastCheck || achDate > lastCheck) {
            // Find achievement details
            for (const cat of Object.keys(achData)) {
                if (achData[cat][achId]) {
                    newFounded.push({ id: achId, ach: achData[cat][achId], date: achDate });
                    break;
                }
            }
        }
    }
    
    // Check for new earned achievements
    const earned = userData.achievements?.earned || {};
    const newEarned = [];
    for (const [achId, timestamp] of Object.entries(earned)) {
        const achDate = new Date(timestamp);
        if (!lastCheck || achDate > lastCheck) {
            for (const cat of Object.keys(achData)) {
                if (achData[cat][achId]) {
                    newEarned.push({ id: achId, ach: achData[cat][achId], date: achDate });
                    break;
                }
            }
        }
    }
    
    // Sort by date (most recent first)
    newFounded.sort((a, b) => b.date - a.date);
    newEarned.sort((a, b) => b.date - a.date);
    
    // Show notifications
    if (newFounded.length > 0) {
        setTimeout(() => {
            showCongratsToast(newFounded[0].ach.name, true);
        }, 500);
    } else if (newEarned.length > 0) {
        setTimeout(() => {
            showCongratsToast(newEarned[0].ach.name, false);
        }, 500);
    }
}

function showCongratsToast(achName, isFounder) {
    const el = document.getElementById('toast');
    if (isFounder) {
        el.textContent = `🌟 Congrats on founding "${achName}"! 🌟`;
        el.className = 'show founder-toast';
    } else {
        el.textContent = `✨ Congrats on earning "${achName}"! ✨`;
        el.className = 'show';
    }
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => { el.className = ''; }, 5000);
}

// ── EVENTS ────────────────────────────────────────────────────────────
document.getElementById('loadBtn').addEventListener('click', () => {
    const v = document.getElementById('userIdInput').value.trim();
    if (v) {
        document.getElementById('autocomplete').classList.remove('visible');
        loadUser(v);
    }
});

document.getElementById('userIdInput').addEventListener('input', e => {
    updateAutocomplete(e.target.value);
});

document.getElementById('userIdInput').addEventListener('keydown', e => {
    const dropdown = document.getElementById('autocomplete');
    const isOpen = dropdown.classList.contains('visible');

    if (e.key === 'ArrowDown' && isOpen) {
        e.preventDefault();
        autocompleteIndex = Math.min(autocompleteIndex + 1, autocompleteMatches.length - 1);
        highlightAutocompleteItem(autocompleteIndex);
    } else if (e.key === 'ArrowUp' && isOpen) {
        e.preventDefault();
        autocompleteIndex = Math.max(autocompleteIndex - 1, -1);
        highlightAutocompleteItem(autocompleteIndex);
    } else if (e.key === 'Enter') {
        e.preventDefault();
        if (isOpen && autocompleteIndex >= 0) {
            selectAutocompleteItem(autocompleteIndex);
        } else {
            const v = e.target.value.trim();
            if (v) {
                dropdown.classList.remove('visible');
                loadUser(v);
            }
        }
    } else if (e.key === 'Escape' && isOpen) {
        dropdown.classList.remove('visible');
    }
});

document.getElementById('autocomplete').addEventListener('click', e => {
    const item = e.target.closest('.autocomplete-item');
    if (item) {
        const index = parseInt(item.dataset.index);
        selectAutocompleteItem(index);
    }
});

document.addEventListener('click', e => {
    const input = document.getElementById('userIdInput');
    const dropdown = document.getElementById('autocomplete');
    if (!input.contains(e.target) && !dropdown.contains(e.target)) {
        dropdown.classList.remove('visible');
    }
});

document.getElementById('showAllBtn').addEventListener('click', () => {
    currentUserId = null;
    currentFilter = 'all';
    updateFilterChips();
    buildSortOptions();
    hideProfile();
    document.getElementById('filterRow').classList.remove('visible');
    document.getElementById('userIdInput').value = '';
    document.getElementById('autocomplete').classList.remove('visible');
    updateTabBadges();
    renderAchievements();
});

document.getElementById('clearBtn').addEventListener('click', () => {
    currentUserId = null;
    currentFilter = 'all';
    updateFilterChips();
    buildSortOptions();
    hideProfile();
    document.getElementById('filterRow').classList.remove('visible');
    document.getElementById('userIdInput').value = '';
    document.getElementById('autocomplete').classList.remove('visible');
    updateTabBadges();
    renderAchievements();
});

document.getElementById('claimBtn').addEventListener('click', () => {
    if (!currentUserId) return;
    
    const userData = allUserData[currentUserId];
    if (!userData) return;
    
    // Find most recent achievement
    const earned = userData.achievements?.earned || {};
    const founded = userData.achievements?.founded || {};
    const all = { ...earned, ...founded };
    
    let mostRecentDate = null;
    for (const timestamp of Object.values(all)) {
        const date = new Date(timestamp);
        if (!mostRecentDate || date > mostRecentDate) {
            mostRecentDate = date;
        }
    }
    
    // Save to cookie
    setCookie('myAchievementsUser', {
        userId: currentUserId,
        username: userData.username || currentUserId,
        lastAchievementDate: mostRecentDate ? mostRecentDate.toISOString() : null
    });
    
    // Update button state immediately
    const claimBtn = document.getElementById('claimBtn');
    claimBtn.classList.add('claimed');
    claimBtn.textContent = 'Saved ✓';
    
    showToast('Saved! Your achievements will auto-load next time.');
});

document.getElementById('leaderboardHeader').addEventListener('click', (e) => {
    document.getElementById('leaderboard').classList.toggle('collapsed');
    cancelLeaderboardTimer();
});

document.getElementById('leaderboardTimerLabel').addEventListener('click', (e) => {
    e.stopPropagation();
    cancelLeaderboardTimer();
    showToast('Leaderboard will stay open');
});

// Star game button - show mode select
document.getElementById('starGameBtn').addEventListener('click', () => {
    if (starGameActive) {
        toggleStarGame(); // If game is active, end it
    } else {
        showModeSelect(); // Otherwise show mode select
    }
});

// Game over modal buttons
document.getElementById('tryAgainBtn').addEventListener('click', () => {
    document.getElementById('gameOverModal').classList.remove('visible');
    toggleStarGame(); // Start a new game
});

document.getElementById('closeGameBtn').addEventListener('click', () => {
    document.getElementById('gameOverModal').classList.remove('visible');
});

document.getElementById('changeModeBtn').addEventListener('click', () => {
    document.getElementById('gameOverModal').classList.remove('visible');
    showModeSelect();
});

// Cheat warning modal button
document.getElementById('cheatOkBtn').addEventListener('click', () => {
    document.getElementById('cheatWarningModal').classList.remove('visible');
    clickTimes = []; // Reset click tracking
    
    // Resume timer if game is still active
    if (starGameActive && !starGameTimerInterval) {
        starGameTimerInterval = setInterval(() => {
            starGameTimeLeft--;
            updateGameScore();
            if (starGameTimeLeft <= 0) {
                toggleStarGame();
            }
        }, 1000);
    }
});

// Mode select cards
document.querySelectorAll('.mode-card').forEach(card => {
    card.addEventListener('click', () => {
        if (card.classList.contains('locked')) {
            showToast('Complete the challenge to unlock this mode!', true);
            return;
        }
        const mode = card.dataset.mode;
        startGameWithMode(mode);
    });
});

// Mode select settings button
document.getElementById('modeSelectSettingsBtn').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('modeSelectModal').classList.remove('visible');
    openAccessibilitySettings();
});

// Accessibility notice OK button
document.getElementById('accessibilityOkBtn').addEventListener('click', () => {
    accessibilitySettings.shownNotice = true;
    setCookie('accessibilitySettings', accessibilitySettings);
    document.getElementById('accessibilityNoticeModal').classList.remove('visible');
    showModeSelect(); // Now show the mode select
});

// Accessibility settings
function openAccessibilitySettings() {
    const modal = document.getElementById('accessibilitySettingsModal');
    // Set current selection
    document.querySelector(`input[name="accessMode"][value="${accessibilitySettings.mode}"]`).checked = true;
    modal.classList.add('visible');
}

document.getElementById('saveAccessibilityBtn').addEventListener('click', () => {
    const selected = document.querySelector('input[name="accessMode"]:checked').value;
    accessibilitySettings.mode = selected;
    setCookie('accessibilitySettings', accessibilitySettings);
    applyAccessibilitySettings();
    document.getElementById('accessibilitySettingsModal').classList.remove('visible');
    showToast('Accessibility settings saved!');
    showModeSelect(); // Return to mode select
});

// Apply accessibility settings
function applyAccessibilitySettings() {
    // Clear any existing intervals
    if (window.accessibilityInterval) {
        clearInterval(window.accessibilityInterval);
        window.accessibilityInterval = null;
    }
    
    // Remove previous spacebar handler if exists
    if (window.spaceHandler) {
        document.removeEventListener('keydown', window.spaceHandler);
        window.spaceHandler = null;
    }
    
    // Abort previous canvas click listeners
    if (window.canvasAbortController) {
        window.canvasAbortController.abort();
    }
    window.canvasAbortController = new AbortController();
    
    if (accessibilitySettings.mode === 'spacebar') {
        // Spacebar click mode
        window.spaceHandler = (e) => {
            if (e.code === 'Space' && (starGameActive || saveStarsActive)) {
                e.preventDefault();
                if (saveStarsActive) {
                    checkBlackHoleClick(mouse.x, mouse.y);
                } else {
                    checkStarClick(mouse.x, mouse.y);
                }
            }
        };
        document.addEventListener('keydown', window.spaceHandler);
        
        // Still allow mouse clicks
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (saveStarsActive) {
                checkBlackHoleClick(x, y);
            } else {
                checkStarClick(x, y);
            }
        }, { signal: window.canvasAbortController.signal });
        
    } else if (accessibilitySettings.mode === 'alwayson') {
        // Always-on cursor mode - 4 clicks per second (every 250ms)
        window.accessibilityInterval = setInterval(() => {
            if (starGameActive && mouse.x && mouse.y) {
                checkStarClick(mouse.x, mouse.y);
            } else if (saveStarsActive && mouse.x && mouse.y) {
                checkBlackHoleClick(mouse.x, mouse.y);
            }
        }, 250); // 4 times per second
        
        // Still allow manual clicks
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (saveStarsActive) {
                checkBlackHoleClick(x, y);
            } else {
                checkStarClick(x, y);
            }
        }, { signal: window.canvasAbortController.signal });
        
    } else {
        // Default mouse-only mode
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (saveStarsActive) {
                checkBlackHoleClick(x, y);
            } else {
                checkStarClick(x, y);
            }
        }, { signal: window.canvasAbortController.signal });
    }
}

// Initialize accessibility on load
applyAccessibilitySettings();

// Easter egg hint for the nerds
console.log('%c↑↑↓↓←→←→BA', 'font-size: 20px; color: #C6E8E8; font-weight: bold;');
console.log('%cClassic gamers know... 🎮', 'color: #999; font-style: italic;');

// ── KONAMI CODE ───────────────────────────────────────────────────────
const konamiSequence = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 
                        'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 
                        'KeyB', 'KeyA'];
let konamiIndex = 0;

function playKonamiChime(isCorrect, isFirst = false) {
    const now = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    if (isCorrect) {
        // Ascending chime for correct keys
        const freq = 400 + (konamiIndex * 100); // Gets higher with each correct key
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);
        
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        osc.start(now);
        osc.stop(now + 0.2);
    } else {
        // Womp womp for wrong key
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
        
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        
        osc.start(now);
        osc.stop(now + 0.3);
    }
}

function playKonamiFanfare() {
    const now = audioContext.currentTime;
    
    // Epic ascending fanfare
    const notes = [523.25, 659.25, 783.99, 1046.50]; // C-E-G-C octave
    
    notes.forEach((freq, i) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        osc.connect(gain);
        gain.connect(audioContext.destination);
        
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, now + (i * 0.15));
        
        gain.gain.setValueAtTime(0.2, now + (i * 0.15));
        gain.gain.exponentialRampToValueAtTime(0.001, now + (i * 0.15) + 0.3);
        
        osc.start(now + (i * 0.15));
        osc.stop(now + (i * 0.15) + 0.3);
    });
}

document.addEventListener('keydown', (e) => {
    // Only listen when not in active game
    if (starGameActive || saveStarsActive) return;
    
    if (e.code === konamiSequence[konamiIndex]) {
        konamiIndex++;
        playKonamiChime(true, konamiIndex === 1);
        
        if (konamiIndex === konamiSequence.length) {
            // Code complete!
            playKonamiFanfare();
            setTimeout(() => {
                showKonamiModal();
            }, 600);
            konamiIndex = 0;
        }
    } else if (konamiSequence.includes(e.code)) {
        // Wrong key in sequence
        playKonamiChime(false);
        konamiIndex = 0;
    }
});

function showKonamiModal() {
    document.getElementById('konamiModal').classList.add('visible');
}

// ── SAVE THE STARS MODE ───────────────────────────────────────────────

// Konami start button
document.getElementById('konamiStartBtn').addEventListener('click', () => {
    document.getElementById('konamiModal').classList.remove('visible');
    startSaveTheStarsMode();
});

function startSaveTheStarsMode() {
    // Make sure star game is off
    if (starGameActive) {
        toggleStarGame();
    }
    
    // Hide profile banner if visible
    document.getElementById('profileBanner').classList.remove('visible');
    document.getElementById('filterRow').classList.remove('visible');
    
    // Set up Save the Stars mode
    saveStarsActive = true;
    playerHP = 500;
    survivalTime = 0;
    blackHoles = [];
    redBlackHoles = [];
    nextBlackHoleDelay = 1500;
    
    // Add body class for game mode
    document.body.classList.add('save-stars-active');
    
    // Update game timer display
    updateSaveStarsUI();
    
    // Start survival timer (counts seconds)
    saveStarsTimer = setInterval(() => {
        survivalTime++;
        updateSaveStarsUI();
    }, 1000);
    
    // Start black hole spawning
    scheduleNextBlackHole();
    
    showToast('Save the stars from the black holes!');
}

function updateSaveStarsUI() {
    // Update HP and time display (will create UI elements)
    const hpDisplay = document.getElementById('saveStarsHP');
    const timeDisplay = document.getElementById('saveStarsTime');
    
    if (hpDisplay) hpDisplay.textContent = playerHP;
    if (timeDisplay) timeDisplay.textContent = survivalTime;
}

function scheduleNextBlackHole() {
    if (!saveStarsActive) return;
    
    // Difficulty scaling - much slower now
    
    nextBlackHoleDelay = Math.max(650, nextBlackHoleDelay * 0.995); 
    

    blackHoleSpawnTimer = setTimeout(() => {
        spawnBlackHole();
        scheduleNextBlackHole();
    }, nextBlackHoleDelay);
}

function spawnBlackHole() {
    const isRed = survivalTime >= 60 && (survivalTime < 90 ? Math.random() < 0.3 : Math.random() < 0.7);
    
    // Fixed center size - only grows for red holes when consuming
    const centerSize = 12; // Fixed small clickable target
    
    // Determine event horizon size based on time
    let minEventSize, maxEventSize;
    if (survivalTime < 10) {
        minEventSize = 40;
        maxEventSize = 60;
    } else if (survivalTime < 30) {
        minEventSize = 50;
        maxEventSize = 80;
    } else {
        minEventSize = 60;
        maxEventSize = 100;
    }
    
    const targetEventSize = minEventSize + Math.random() * (maxEventSize - minEventSize);
    
    // Safe boundaries for spawning (account for mobile, leave 100px margin)
    const margin = 100;
    const safeMinX = margin;
    const safeMaxX = w - margin;
    const safeMinY = margin;
    const safeMaxY = h - margin;
    
    // Try to find a position away from stars (up to 10 attempts)
    let x, y, tooClose;
    let attempts = 0;
    do {
        x = safeMinX + Math.random() * (safeMaxX - safeMinX);
        y = safeMinY + Math.random() * (safeMaxY - safeMinY);
        
        // Check if too close to any star
        tooClose = false;
        const minDistanceFromStar = 80; // Stay at least 80px from stars
        for (const star of stars) {
            const dx = star.x - x;
            const dy = star.y - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDistanceFromStar) {
                tooClose = true;
                break;
            }
        }
        attempts++;
    } while (tooClose && attempts < 10);
    
    const blackHole = {
        x: x,
        y: y,
        centerRadius: 0, // Start at 0 for spawn animation
        eventRadius: 0, // Start at 0 for spawn animation
        targetCenterRadius: centerSize, // Target size
        targetEventRadius: targetEventSize, // Target size
        growthRate: 0.5, // pixels per frame for center
        eventGrowthRate: 2, // Event horizon grows 2x faster
        hp: isRed ? centerSize * 3 : 0, // Red holes have HP (increased since center is smaller)
        maxHP: isRed ? centerSize * 3 : 0,
        isRed: isRed,
        age: 0,
        spawning: true, // Flag for spawn animation
        spawnProgress: 0 // 0 to 1
    };
    
    if (isRed) {
        redBlackHoles.push(blackHole);
    } else {
        blackHoles.push(blackHole);
    }
}

function updateAndDrawBlackHoles() {
    const allBlackHoles = [...blackHoles, ...redBlackHoles];
    
    for (const bh of allBlackHoles) {
        bh.age++;
        
        // Handle spawn animation
        if (bh.spawning) {
            bh.spawnProgress += 0.022; // Fast spawn animation
            if (bh.spawnProgress >= 1) {
                bh.spawnProgress = 1;
                bh.spawning = false;
            }
            // Ease-in cubic for smooth spawn
            const easeProgress = bh.spawnProgress * bh.spawnProgress * bh.spawnProgress;
            bh.centerRadius = bh.targetCenterRadius * easeProgress;
            bh.eventRadius = bh.targetEventRadius * easeProgress;
        } else {
            // Normal growth after spawn
            // Event horizon grows faster after 60 seconds for purple holes
            let eventGrowthMultiplier = 1;
            if (!bh.isRed && survivalTime >= 30 && survivalTime <= 60) {
                eventGrowthMultiplier = 2; // 4) Double speed after 60s for purple
            }
            if (!bh.isRed && survivalTime >= 60 && survivalTime <= 120) {
                eventGrowthMultiplier = 4; // 4) Double speed after 60s for purple
            }
            if (!bh.isRed && survivalTime >= 120) {
                eventGrowthMultiplier = 6; // 4) Double speed after 60s for purple
            }
            if(bh.isRed && survivalTime >= 90 && survivalTime <= 120){
                eventGrowthMultiplier = 2;
            }
            if(bh.isRed && survivalTime >= 120){
                eventGrowthMultiplier = 4;
            }
            bh.eventRadius += bh.eventGrowthRate * 0.016 * eventGrowthMultiplier;
            // Center only grows for red holes when consuming (handled in consumeStar)
        }
        
        // Draw event horizon (transparent purple/red circle with swirl)
        const gradient = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, Math.max(1, bh.eventRadius));
        if (bh.isRed) {
            gradient.addColorStop(0, 'rgba(150, 0, 50, 0.8)');
            gradient.addColorStop(0.5, 'rgba(100, 0, 50, 0.4)');
            gradient.addColorStop(1, 'rgba(50, 0, 30, 0)');
        } else {
            gradient.addColorStop(0, 'rgba(100, 0, 150, 0.8)');
            gradient.addColorStop(0.5, 'rgba(80, 0, 120, 0.4)');
            gradient.addColorStop(1, 'rgba(50, 0, 80, 0)');
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(bh.x, bh.y, bh.eventRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw swirl effect - each arc spins at different speed
        ctx.save();
        ctx.translate(bh.x, bh.y);
        ctx.strokeStyle = bh.isRed ? 'rgba(255, 50, 100, 0.3)' : 'rgba(150, 100, 255, 0.3)';
        ctx.lineWidth = 2;
        
        const speeds = [0.05, 0.08, 0.12]; // Different rotation speeds for each arc
        for (let i = 0; i < 3; i++) {
            ctx.save();
            ctx.rotate(bh.age * speeds[i]); // Each arc rotates at different speed
            const swirlRadius = Math.max(1, bh.eventRadius * 0.7 - (i * 10)); // Prevent negative
            ctx.beginPath();
            ctx.arc(0, 0, swirlRadius, 0, Math.PI * 1.5);
            ctx.stroke();
            ctx.restore();
        }
        ctx.restore();
        
        // Draw center (clickable death zone)
        const centerGradient = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, bh.centerRadius);
        if (bh.isRed) {
            centerGradient.addColorStop(0, 'rgba(200, 0, 50, 1)');
            centerGradient.addColorStop(1, 'rgba(100, 0, 50, 0.8)');
        } else {
            centerGradient.addColorStop(0, 'rgba(150, 0, 200, 1)');
            centerGradient.addColorStop(1, 'rgba(100, 0, 150, 0.8)');
        }
        ctx.fillStyle = centerGradient;
        ctx.beginPath();
        ctx.arc(bh.x, bh.y, bh.centerRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Apply gravity to stars
        applyBlackHoleGravity(bh);
    }
}

function applyBlackHoleGravity(bh) {
    for (const star of stars) {
        const dx = bh.x - star.x;
        const dy = bh.y - star.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Check if in event horizon
        if (dist < bh.eventRadius) {
            // Check for consumption (center collision)
            if (dist < bh.centerRadius) {
                consumeStar(star, bh);
                continue;
            }
            
            // Apply gravity pull (inverse square, stronger near center)
            const pullStrength = (bh.eventRadius / dist) * 0.5;
            const normalizedDist = dist / bh.eventRadius; // 0-1, where 0 is center
            const gravityMultiplier = Math.pow(1 - normalizedDist, 2); // Quadratic falloff
            
            star.vx += (dx / dist) * pullStrength * gravityMultiplier * 0.05;
            star.vy += (dy / dist) * pullStrength * gravityMultiplier * 0.05;
            
            // Turn red as they get closer
            star.danger = 1 - normalizedDist; // 0-1, where 1 is most danger
        } else {
            star.danger = 0;
        }
    }
}

function consumeStar(star, bh) {
    // Determine star HP value
    let starHP = 1; // Default small star
    
    // Check if it's a twinkle star
    const isTwinkle = twinklingStars.some(ts => 
        Math.abs(ts.x - star.x) < 5 && Math.abs(ts.y - star.y) < 5
    );
    
    if (isTwinkle) {
        const twinkleStar = twinklingStars.find(ts => 
            Math.abs(ts.x - star.x) < 5 && Math.abs(ts.y - star.y) < 5
        );
        if (twinkleStar) {
            starHP = twinkleStar.isFast ? 5 : 2;
            // Remove from twinkle array
            const idx = twinklingStars.indexOf(twinkleStar);
            if (idx > -1) twinklingStars.splice(idx, 1);
        }
    }
    
    // Damage player
    playerHP = Math.max(0, playerHP - starHP);
    
    // Red black holes grow when consuming
    if (bh.isRed) {
        const growthAmount = starHP * 0.02; // 2% per HP
        bh.centerRadius *= (1 + growthAmount);
        bh.eventRadius *= (1 + growthAmount);
        bh.hp += starHP * 5; // Gain HP too
        bh.maxHP += starHP * 5;
        
        // Red pulse effect
        playRedBlackHoleConsume();
    } else {
        playBlackHoleConsume();
    }
    
    // Respawn star
    star.x = Math.random() * w;
    star.y = Math.random() * h;
    star.vx = (Math.random() - 0.5) * 0.3;
    star.vy = (Math.random() - 0.5) * 0.3;
    star.danger = 0;
    
    updateSaveStarsUI();
    
    // Check game over
    if (playerHP <= 0) {
        endSaveTheStarsMode();
    }
}

function playBlackHoleConsume() {
    const now = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
    
    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    
    osc.start(now);
    osc.stop(now + 0.3);
}

function playRedBlackHoleConsume() {
    const now = audioContext.currentTime;
    
    // More aggressive sound
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    const filter = audioContext.createBiquadFilter();
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, now);
    osc.frequency.exponentialRampToValueAtTime(30, now + 0.4);
    
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(1000, now);
    filter.frequency.exponentialRampToValueAtTime(100, now + 0.4);
    
    gain.gain.setValueAtTime(0.2, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
    
    osc.start(now);
    osc.stop(now + 0.4);
}

function endSaveTheStarsMode() {
    saveStarsActive = false;
    document.body.classList.remove('save-stars-active');
    
    clearInterval(saveStarsTimer);
    clearTimeout(blackHoleSpawnTimer);
    
    blackHoles = [];
    redBlackHoles = [];
    
    // Reset all stars
    for (const star of stars) {
        star.danger = 0;
    }
    
    showToast(`Game Over! You survived ${survivalTime} seconds!`);
}

function checkBlackHoleClick(x, y) {
    const clickRadius = 25; // Increased from 10 for easier clicking
    
    // Check red black holes first (priority)
    for (let i = redBlackHoles.length - 1; i >= 0; i--) {
        const bh = redBlackHoles[i];
        const dx = bh.x - x;
        const dy = bh.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < bh.centerRadius + clickRadius) {
            console.log('Red black hole clicked!', 'HP:', bh.hp, 'Radius:', bh.centerRadius);
            if (bh.hp > 20) {
                // Damage the black hole
                bh.hp -= 10;
                bh.centerRadius = Math.max(5, bh.centerRadius * 0.95); // Shrink but minimum 5px
                bh.eventRadius = Math.max(10, bh.eventRadius * 0.95); // Minimum 10px
                playBlackHoleHit();
            } else {
                // Destroy it
                redBlackHoles.splice(i, 1);
                playBlackHoleDestroy();
                createParticles(bh.x, bh.y, '255, 0, 100', 25); // Bright red/pink particles
            }
            return;
        }
    }
    
    // Check normal black holes
    for (let i = blackHoles.length - 1; i >= 0; i--) {
        const bh = blackHoles[i];
        const dx = bh.x - x;
        const dy = bh.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < bh.centerRadius + clickRadius) {
            console.log('Normal black hole clicked! Destroying...');
            blackHoles.splice(i, 1);
            playBlackHoleDestroy();
            createParticles(bh.x, bh.y, '180, 100, 255', 20); // Bright purple particles
            return;
        }
    }
    
    console.log('No black hole hit at', x, y, 'Normal holes:', blackHoles.length, 'Red holes:', redBlackHoles.length);
}

function playBlackHoleHit() {
    const now = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.type = 'square';
    osc.frequency.setValueAtTime(300, now);
    
    gain.gain.setValueAtTime(0.1, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
    
    osc.start(now);
    osc.stop(now + 0.1);
}

function playBlackHoleDestroy() {
    const now = audioContext.currentTime;
    
    // Satisfying pop
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, now);
    osc.frequency.exponentialRampToValueAtTime(200, now + 0.2);
    
    gain.gain.setValueAtTime(0.2, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
    
    osc.start(now);
    osc.stop(now + 0.2);
}

// Click outside mode select to close it
document.getElementById('modeSelectModal').addEventListener('click', (e) => {
    if (e.target.id === 'modeSelectModal') {
        document.getElementById('modeSelectModal').classList.remove('visible');
    }
});

// Event delegation for clicking recent user items in dropdowns
document.getElementById('achievementsContainer').addEventListener('click', (e) => {
    const recentItem = e.target.closest('.recent-user-item');
    if (recentItem && recentItem.dataset.userid) {
        loadUser(recentItem.dataset.userid);
        document.getElementById('userIdInput').value = recentItem.querySelector('.recent-user-name').textContent;
    }
});

document.getElementById('filterRow').addEventListener('click', e => {
    const chip = e.target.closest('.filter-chip');
    if (!chip) return;
    currentFilter = chip.dataset.filter;
    updateFilterChips();
    renderAchievements();
});

document.getElementById('sortSelect').addEventListener('change', e => {
    currentSort = e.target.value;
    renderAchievements();
});

// ── UTIL ──────────────────────────────────────────────────────────────
function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

// ── STARTUP ───────────────────────────────────────────────────────────
loadAllData().then(() => initPage());
</script>
</body>
</html>
